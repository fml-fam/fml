<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fml: fml::cpumat&lt; REAL &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fml_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fml
   &#160;<span id="projectnumber">0.1-0</span>
   </div>
   <div id="projectbrief">Fused Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfml_1_1cpumat.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classfml_1_1cpumat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fml::cpumat&lt; REAL &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix class for data held on a single CPU.  
 <a href="classfml_1_1cpumat.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpumat_8hh_source.html">cpumat.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fml::cpumat&lt; REAL &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfml_1_1cpumat.png" usemap="#fml::cpumat_3C_20REAL_20_3E_map" alt=""/>
  <map id="fml::cpumat_3C_20REAL_20_3E_map" name="fml::cpumat_3C_20REAL_20_3E_map">
<area href="classfml_1_1unimat.html" title="Base matrix class. Not meant for direct use. Instead see cpumat, gpumat, and mpimat." alt="fml::unimat&lt; REAL &gt;" shape="rect" coords="0,0,130,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00bd08ac6de0877482b7ce37fc350afa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a00bd08ac6de0877482b7ce37fc350afa">cpumat</a> ()</td></tr>
<tr class="memdesc:a00bd08ac6de0877482b7ce37fc350afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object with no internal allocated storage.  <a href="classfml_1_1cpumat.html#a00bd08ac6de0877482b7ce37fc350afa">More...</a><br /></td></tr>
<tr class="separator:a00bd08ac6de0877482b7ce37fc350afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45b1d2a9c179ca6c225ef28c6139092"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ae45b1d2a9c179ca6c225ef28c6139092">cpumat</a> (len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>)</td></tr>
<tr class="memdesc:ae45b1d2a9c179ca6c225ef28c6139092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object.  <a href="classfml_1_1cpumat.html#ae45b1d2a9c179ca6c225ef28c6139092">More...</a><br /></td></tr>
<tr class="separator:ae45b1d2a9c179ca6c225ef28c6139092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac536cbf5354bb1ab16865b09790f7e15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ac536cbf5354bb1ab16865b09790f7e15">cpumat</a> (REAL *data, len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>, bool free_on_destruct=false)</td></tr>
<tr class="memdesc:ac536cbf5354bb1ab16865b09790f7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object with inherited data. Essentially the same as using the minimal constructor and immediately calling the <code><a class="el" href="classfml_1_1cpumat.html#a3335dc81a02a28d5c29d5a964d7e1a54" title="Set the internal object storage to the specified array.">inherit()</a></code> method.  <a href="classfml_1_1cpumat.html#ac536cbf5354bb1ab16865b09790f7e15">More...</a><br /></td></tr>
<tr class="separator:ac536cbf5354bb1ab16865b09790f7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa9df37787e25ea2ef9c445a83150d2"><td class="memItemLeft" align="right" valign="top"><a id="a9fa9df37787e25ea2ef9c445a83150d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cpumat</b> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a> &amp;&amp;x)</td></tr>
<tr class="separator:a9fa9df37787e25ea2ef9c445a83150d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1a0a34e1fd80bca54c230fc087922d"><td class="memItemLeft" align="right" valign="top"><a id="a1d1a0a34e1fd80bca54c230fc087922d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cpumat</b> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a> &amp;x)</td></tr>
<tr class="separator:a1d1a0a34e1fd80bca54c230fc087922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73dece47634d7372a38b27207c74a2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ad73dece47634d7372a38b27207c74a2d">resize</a> (len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>)</td></tr>
<tr class="memdesc:ad73dece47634d7372a38b27207c74a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the internal object storage.  <a href="classfml_1_1cpumat.html#ad73dece47634d7372a38b27207c74a2d">More...</a><br /></td></tr>
<tr class="separator:ad73dece47634d7372a38b27207c74a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3335dc81a02a28d5c29d5a964d7e1a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a3335dc81a02a28d5c29d5a964d7e1a54">inherit</a> (REAL *data, len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>, bool free_on_destruct=false)</td></tr>
<tr class="memdesc:a3335dc81a02a28d5c29d5a964d7e1a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal object storage to the specified array.  <a href="classfml_1_1cpumat.html#a3335dc81a02a28d5c29d5a964d7e1a54">More...</a><br /></td></tr>
<tr class="separator:a3335dc81a02a28d5c29d5a964d7e1a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5be5191e72381860ddbfedfc7580db4"><td class="memItemLeft" align="right" valign="top"><a id="ae5be5191e72381860ddbfedfc7580db4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ae5be5191e72381860ddbfedfc7580db4">inherit</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;data)</td></tr>
<tr class="memdesc:ae5be5191e72381860ddbfedfc7580db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae5be5191e72381860ddbfedfc7580db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2e3a2f4a3a5ec3ff4af4c303e30249"><td class="memItemLeft" align="right" valign="top"><a id="a2f2e3a2f4a3a5ec3ff4af4c303e30249"></a>
<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a2f2e3a2f4a3a5ec3ff4af4c303e30249">dupe</a> () const</td></tr>
<tr class="memdesc:a2f2e3a2f4a3a5ec3ff4af4c303e30249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the object in a deep copy. <br /></td></tr>
<tr class="separator:a2f2e3a2f4a3a5ec3ff4af4c303e30249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3efe331b1ee362489fad7a9e20e4db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#aa3efe331b1ee362489fad7a9e20e4db3">print</a> (uint8_t ndigits=4, bool add_final_blank=true) const</td></tr>
<tr class="memdesc:aa3efe331b1ee362489fad7a9e20e4db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all values in the object.  <a href="classfml_1_1cpumat.html#aa3efe331b1ee362489fad7a9e20e4db3">More...</a><br /></td></tr>
<tr class="separator:aa3efe331b1ee362489fad7a9e20e4db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92c1778fbcaea57c093339d592ae3de"><td class="memItemLeft" align="right" valign="top"><a id="af92c1778fbcaea57c093339d592ae3de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#af92c1778fbcaea57c093339d592ae3de">info</a> () const</td></tr>
<tr class="memdesc:af92c1778fbcaea57c093339d592ae3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some brief information about the object. <br /></td></tr>
<tr class="separator:af92c1778fbcaea57c093339d592ae3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b12d382a45e49f6934d57d78e2963e"><td class="memItemLeft" align="right" valign="top"><a id="ae7b12d382a45e49f6934d57d78e2963e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ae7b12d382a45e49f6934d57d78e2963e">fill_zero</a> ()</td></tr>
<tr class="memdesc:ae7b12d382a45e49f6934d57d78e2963e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values to zero. <br /></td></tr>
<tr class="separator:ae7b12d382a45e49f6934d57d78e2963e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6729880f298d58de70fa22dd05ae80e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a6729880f298d58de70fa22dd05ae80e5">fill_val</a> (const REAL v)</td></tr>
<tr class="memdesc:a6729880f298d58de70fa22dd05ae80e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values to input value.  <a href="classfml_1_1cpumat.html#a6729880f298d58de70fa22dd05ae80e5">More...</a><br /></td></tr>
<tr class="separator:a6729880f298d58de70fa22dd05ae80e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81237f19ed4e258fc52f7fc5e3eae68f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a81237f19ed4e258fc52f7fc5e3eae68f">fill_linspace</a> (const REAL start, const REAL stop)</td></tr>
<tr class="memdesc:a81237f19ed4e258fc52f7fc5e3eae68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values to linearly spaced numbers.  <a href="classfml_1_1cpumat.html#a81237f19ed4e258fc52f7fc5e3eae68f">More...</a><br /></td></tr>
<tr class="separator:a81237f19ed4e258fc52f7fc5e3eae68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8c6a6b28726b103dca06acdb897409"><td class="memItemLeft" align="right" valign="top"><a id="a3d8c6a6b28726b103dca06acdb897409"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a3d8c6a6b28726b103dca06acdb897409">fill_eye</a> ()</td></tr>
<tr class="memdesc:a3d8c6a6b28726b103dca06acdb897409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0. <br /></td></tr>
<tr class="separator:a3d8c6a6b28726b103dca06acdb897409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1d1e634440e01113a52c13f4600ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a3dd1d1e634440e01113a52c13f4600ae">fill_diag</a> (const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a3dd1d1e634440e01113a52c13f4600ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries of the matrix to those in the vector.  <a href="classfml_1_1cpumat.html#a3dd1d1e634440e01113a52c13f4600ae">More...</a><br /></td></tr>
<tr class="separator:a3dd1d1e634440e01113a52c13f4600ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187ad255fd5eafd80e22c239f1ce59ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a187ad255fd5eafd80e22c239f1ce59ed">fill_runif</a> (const uint32_t seed, const REAL min=0, const REAL max=1)</td></tr>
<tr class="memdesc:a187ad255fd5eafd80e22c239f1ce59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="classfml_1_1cpumat.html#a187ad255fd5eafd80e22c239f1ce59ed">More...</a><br /></td></tr>
<tr class="separator:a187ad255fd5eafd80e22c239f1ce59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed62a1e8ddb827936e08bf2ebf23194"><td class="memItemLeft" align="right" valign="top"><a id="a1ed62a1e8ddb827936e08bf2ebf23194"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a1ed62a1e8ddb827936e08bf2ebf23194">fill_runif</a> (const REAL min=0, const REAL max=1)</td></tr>
<tr class="memdesc:a1ed62a1e8ddb827936e08bf2ebf23194"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a1ed62a1e8ddb827936e08bf2ebf23194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a49cf368cbaf985e6b6d02fcf2eddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a64a49cf368cbaf985e6b6d02fcf2eddc">fill_rnorm</a> (const uint32_t seed, const REAL mean=0, const REAL sd=1)</td></tr>
<tr class="memdesc:a64a49cf368cbaf985e6b6d02fcf2eddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="classfml_1_1cpumat.html#a64a49cf368cbaf985e6b6d02fcf2eddc">More...</a><br /></td></tr>
<tr class="separator:a64a49cf368cbaf985e6b6d02fcf2eddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac631e7f1737e5e6adf9077e8adfd9183"><td class="memItemLeft" align="right" valign="top"><a id="ac631e7f1737e5e6adf9077e8adfd9183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ac631e7f1737e5e6adf9077e8adfd9183">fill_rnorm</a> (const REAL mean=0, const REAL sd=1)</td></tr>
<tr class="memdesc:ac631e7f1737e5e6adf9077e8adfd9183"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac631e7f1737e5e6adf9077e8adfd9183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce8a4749274cec16f928d2037e7bacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a4ce8a4749274cec16f928d2037e7bacf">diag</a> (<a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a4ce8a4749274cec16f928d2037e7bacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diagonal entries.  <a href="classfml_1_1cpumat.html#a4ce8a4749274cec16f928d2037e7bacf">More...</a><br /></td></tr>
<tr class="separator:a4ce8a4749274cec16f928d2037e7bacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ee5accfb6dddf1528fbba2b81fe18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ab88ee5accfb6dddf1528fbba2b81fe18">antidiag</a> (<a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:ab88ee5accfb6dddf1528fbba2b81fe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the anti-diagonal entries, i.e. those on the bottom-left to top-right.  <a href="classfml_1_1cpumat.html#ab88ee5accfb6dddf1528fbba2b81fe18">More...</a><br /></td></tr>
<tr class="separator:ab88ee5accfb6dddf1528fbba2b81fe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7567afa9f0783601834bdff4bebe4bdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a7567afa9f0783601834bdff4bebe4bdb">scale</a> (const REAL s)</td></tr>
<tr class="memdesc:a7567afa9f0783601834bdff4bebe4bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all values by the input value.  <a href="classfml_1_1cpumat.html#a7567afa9f0783601834bdff4bebe4bdb">More...</a><br /></td></tr>
<tr class="separator:a7567afa9f0783601834bdff4bebe4bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970025b4f60b73af87710d65a1e84e6e"><td class="memItemLeft" align="right" valign="top"><a id="a970025b4f60b73af87710d65a1e84e6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a970025b4f60b73af87710d65a1e84e6e">rev_rows</a> ()</td></tr>
<tr class="memdesc:a970025b4f60b73af87710d65a1e84e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the rows of the matrix. <br /></td></tr>
<tr class="separator:a970025b4f60b73af87710d65a1e84e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52987a6f3a70c5c16c79de970e3ee98"><td class="memItemLeft" align="right" valign="top"><a id="ac52987a6f3a70c5c16c79de970e3ee98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ac52987a6f3a70c5c16c79de970e3ee98">rev_cols</a> ()</td></tr>
<tr class="memdesc:ac52987a6f3a70c5c16c79de970e3ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the columns of the matrix. <br /></td></tr>
<tr class="separator:ac52987a6f3a70c5c16c79de970e3ee98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab489f5641c5972d624759d4c09405535"><td class="memItemLeft" align="right" valign="top"><a id="ab489f5641c5972d624759d4c09405535"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#ab489f5641c5972d624759d4c09405535">any_inf</a> () const</td></tr>
<tr class="memdesc:ab489f5641c5972d624759d4c09405535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are any values infinite? <br /></td></tr>
<tr class="separator:ab489f5641c5972d624759d4c09405535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110a5492e77a832650e0016c2f98fae1"><td class="memItemLeft" align="right" valign="top"><a id="a110a5492e77a832650e0016c2f98fae1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a110a5492e77a832650e0016c2f98fae1">any_nan</a> () const</td></tr>
<tr class="memdesc:a110a5492e77a832650e0016c2f98fae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are any values NaN? <br /></td></tr>
<tr class="separator:a110a5492e77a832650e0016c2f98fae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277d0f6a183df63ea1fea36c0523f1eb"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a277d0f6a183df63ea1fea36c0523f1eb">get</a> (const len_t i) const</td></tr>
<tr class="memdesc:a277d0f6a183df63ea1fea36c0523f1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified value.  <a href="classfml_1_1cpumat.html#a277d0f6a183df63ea1fea36c0523f1eb">More...</a><br /></td></tr>
<tr class="separator:a277d0f6a183df63ea1fea36c0523f1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4ddb2386c786a27db44b999c878bf"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a55b4ddb2386c786a27db44b999c878bf">get</a> (const len_t i, const len_t j) const</td></tr>
<tr class="memdesc:a55b4ddb2386c786a27db44b999c878bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified value.  <a href="classfml_1_1cpumat.html#a55b4ddb2386c786a27db44b999c878bf">More...</a><br /></td></tr>
<tr class="separator:a55b4ddb2386c786a27db44b999c878bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fc5c1fcc0a1276d778539ad6298abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a49fc5c1fcc0a1276d778539ad6298abb">set</a> (const len_t i, const REAL v)</td></tr>
<tr class="memdesc:a49fc5c1fcc0a1276d778539ad6298abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage at the specified index with the provided value.  <a href="classfml_1_1cpumat.html#a49fc5c1fcc0a1276d778539ad6298abb">More...</a><br /></td></tr>
<tr class="separator:a49fc5c1fcc0a1276d778539ad6298abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e8ccf192ffa7ce15a63ba3610ba740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#af4e8ccf192ffa7ce15a63ba3610ba740">set</a> (const len_t i, const len_t j, const REAL v)</td></tr>
<tr class="memdesc:af4e8ccf192ffa7ce15a63ba3610ba740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage at the specified index with the provided value.  <a href="classfml_1_1cpumat.html#af4e8ccf192ffa7ce15a63ba3610ba740">More...</a><br /></td></tr>
<tr class="separator:af4e8ccf192ffa7ce15a63ba3610ba740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56709907678a3a73bc25b09780c8837"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#af56709907678a3a73bc25b09780c8837">get_row</a> (const len_t i, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v) const</td></tr>
<tr class="memdesc:af56709907678a3a73bc25b09780c8837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified row.  <a href="classfml_1_1cpumat.html#af56709907678a3a73bc25b09780c8837">More...</a><br /></td></tr>
<tr class="separator:af56709907678a3a73bc25b09780c8837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321eb5acfb80c659a1ca3fb54d4b2da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a321eb5acfb80c659a1ca3fb54d4b2da9">get_col</a> (const len_t j, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v) const</td></tr>
<tr class="memdesc:a321eb5acfb80c659a1ca3fb54d4b2da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified column.  <a href="classfml_1_1cpumat.html#a321eb5acfb80c659a1ca3fb54d4b2da9">More...</a><br /></td></tr>
<tr class="separator:a321eb5acfb80c659a1ca3fb54d4b2da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3171e0d622bd18a7255860e0fe55c4d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a3171e0d622bd18a7255860e0fe55c4d7">operator==</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x) const</td></tr>
<tr class="memdesc:a3171e0d622bd18a7255860e0fe55c4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the two objects are the same.  <a href="classfml_1_1cpumat.html#a3171e0d622bd18a7255860e0fe55c4d7">More...</a><br /></td></tr>
<tr class="separator:a3171e0d622bd18a7255860e0fe55c4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488f5f9d4d70da7e107a13b3017f9ca0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a488f5f9d4d70da7e107a13b3017f9ca0">operator!=</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x) const</td></tr>
<tr class="memdesc:a488f5f9d4d70da7e107a13b3017f9ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the two objects are not the same. Uses same internal logic as the <code>==</code> method.  <a href="classfml_1_1cpumat.html#a488f5f9d4d70da7e107a13b3017f9ca0">More...</a><br /></td></tr>
<tr class="separator:a488f5f9d4d70da7e107a13b3017f9ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12887b66ab784ca6d26b52a967091eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a12887b66ab784ca6d26b52a967091eff">operator=</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a12887b66ab784ca6d26b52a967091eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator that sets the LHS to a shallow copy of the input. Desctruction of the LHS object will not result in the internal array storage being freed.  <a href="classfml_1_1cpumat.html#a12887b66ab784ca6d26b52a967091eff">More...</a><br /></td></tr>
<tr class="separator:a12887b66ab784ca6d26b52a967091eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8de1702dbd28a75ea10ac10fb4f9f4"><td class="memItemLeft" align="right" valign="top"><a id="a5c8de1702dbd28a75ea10ac10fb4f9f4"></a>
<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1cpumat.html#a5c8de1702dbd28a75ea10ac10fb4f9f4">operator=</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a5c8de1702dbd28a75ea10ac10fb4f9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a5c8de1702dbd28a75ea10ac10fb4f9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f5b2ba056530b5fca5f0f25dacb7b2"><td class="memItemLeft" align="right" valign="top"><a id="a92f5b2ba056530b5fca5f0f25dacb7b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_linspace</b> (const int start, const int stop)</td></tr>
<tr class="separator:a92f5b2ba056530b5fca5f0f25dacb7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classfml_1_1unimat"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classfml_1_1unimat')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classfml_1_1unimat.html">fml::unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a284ad0870284f7a8542c4f0974d33979 inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a284ad0870284f7a8542c4f0974d33979"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a284ad0870284f7a8542c4f0974d33979">is_square</a> () const</td></tr>
<tr class="memdesc:a284ad0870284f7a8542c4f0974d33979 inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the matrix square? <br /></td></tr>
<tr class="separator:a284ad0870284f7a8542c4f0974d33979 inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b70212a4383826986be87aad3b8908e inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a5b70212a4383826986be87aad3b8908e"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a> () const</td></tr>
<tr class="memdesc:a5b70212a4383826986be87aad3b8908e inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br /></td></tr>
<tr class="separator:a5b70212a4383826986be87aad3b8908e inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184e02405d68317c536b81e4a512bf4 inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a6184e02405d68317c536b81e4a512bf4"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a> () const</td></tr>
<tr class="memdesc:a6184e02405d68317c536b81e4a512bf4 inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br /></td></tr>
<tr class="separator:a6184e02405d68317c536b81e4a512bf4 inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d05f3e788f0597dfc362f1090c002b inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a38d05f3e788f0597dfc362f1090c002b"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a38d05f3e788f0597dfc362f1090c002b">data_ptr</a> ()</td></tr>
<tr class="memdesc:a38d05f3e788f0597dfc362f1090c002b inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the internal array. <br /></td></tr>
<tr class="separator:a38d05f3e788f0597dfc362f1090c002b inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae453388ec85006b432addc857a7376b8 inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ae453388ec85006b432addc857a7376b8"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><b>data_ptr</b> () const</td></tr>
<tr class="separator:ae453388ec85006b432addc857a7376b8 inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad6a5eda5ca0b28299c1e7cc0b08e6cae"><td class="memItemLeft" align="right" valign="top"><a id="ad6a5eda5ca0b28299c1e7cc0b08e6cae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>free_on_destruct</b> () const</td></tr>
<tr class="separator:ad6a5eda5ca0b28299c1e7cc0b08e6cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453f3fb619b099fba80b6dc2025e5152"><td class="memItemLeft" align="right" valign="top"><a id="a453f3fb619b099fba80b6dc2025e5152"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dont_free_on_destruct</b> ()</td></tr>
<tr class="separator:a453f3fb619b099fba80b6dc2025e5152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classfml_1_1unimat"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classfml_1_1unimat')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classfml_1_1unimat.html">fml::unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a36e47630447174d37eca514f6db1d15d inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a36e47630447174d37eca514f6db1d15d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>should_free</b> () const</td></tr>
<tr class="separator:a36e47630447174d37eca514f6db1d15d inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a19947e5e9e6da1ef95b50933a2ea9 inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ab0a19947e5e9e6da1ef95b50933a2ea9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_index</b> (const len_t i) const</td></tr>
<tr class="separator:ab0a19947e5e9e6da1ef95b50933a2ea9 inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef9b60c6468e711a17eaaf23235e5b6 inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a4ef9b60c6468e711a17eaaf23235e5b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_index</b> (const len_t i, const len_t j) const</td></tr>
<tr class="separator:a4ef9b60c6468e711a17eaaf23235e5b6 inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee5c5122090ab3615cb769ea453be2f inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a2ee5c5122090ab3615cb769ea453be2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printval</b> (const REAL val, uint8_t ndigits) const</td></tr>
<tr class="separator:a2ee5c5122090ab3615cb769ea453be2f inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6691e20c10b9b9c2705bdce6ef3cdeeb inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a6691e20c10b9b9c2705bdce6ef3cdeeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printval</b> (const int val, uint8_t ndigits) const</td></tr>
<tr class="separator:a6691e20c10b9b9c2705bdce6ef3cdeeb inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classfml_1_1unimat"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classfml_1_1unimat')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classfml_1_1unimat.html">fml::unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a5231e4efcaf932db382cde7506025825 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a5231e4efcaf932db382cde7506025825"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a5231e4efcaf932db382cde7506025825 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd837691fa367593668036257f2ea7 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ac0cd837691fa367593668036257f2ea7"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:ac0cd837691fa367593668036257f2ea7 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66baf83543ab8d784aa8d52cb198ba93 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a66baf83543ab8d784aa8d52cb198ba93"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a66baf83543ab8d784aa8d52cb198ba93 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04cf20d1d3c2bac8a855fe52ae8a9b3 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ac04cf20d1d3c2bac8a855fe52ae8a9b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>free_data</b></td></tr>
<tr class="separator:ac04cf20d1d3c2bac8a855fe52ae8a9b3 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename REAL&gt;<br />
class fml::cpumat&lt; REAL &gt;</h3>

<p>Matrix class for data held on a single CPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00bd08ac6de0877482b7ce37fc350afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bd08ac6de0877482b7ce37fc350afa">&#9670;&nbsp;</a></span>cpumat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1cpumat.html">cpumat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object with no internal allocated storage. </p>
<div class="fragment"><div class="line">cpumat&lt;float&gt; x();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae45b1d2a9c179ca6c225ef28c6139092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45b1d2a9c179ca6c225ef28c6139092">&#9670;&nbsp;</a></span>cpumat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1cpumat.html">cpumat</a> </td>
          <td>(</td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the allocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<div class="fragment"><div class="line">cpumat&lt;float&gt; x(3, 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac536cbf5354bb1ab16865b09790f7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac536cbf5354bb1ab16865b09790f7e15">&#9670;&nbsp;</a></span>cpumat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1cpumat.html">cpumat</a> </td>
          <td>(</td>
          <td class="paramtype">REAL *&#160;</td>
          <td class="paramname"><em>data_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destruct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object with inherited data. Essentially the same as using the minimal constructor and immediately calling the <code><a class="el" href="classfml_1_1cpumat.html#a3335dc81a02a28d5c29d5a964d7e1a54" title="Set the internal object storage to the specified array.">inherit()</a></code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_</td><td>Storage array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the array, i.e. the length of the array is nrows*ncols. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_on_destruct</td><td>Should the inherited array <code>data_</code> be freed when the matrix object is destroyed?</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab88ee5accfb6dddf1528fbba2b81fe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88ee5accfb6dddf1528fbba2b81fe18">&#9670;&nbsp;</a></span>antidiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::antidiag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the anti-diagonal entries, i.e. those on the bottom-left to top-right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The anti-diagonal. Length should match the length of the diagonal of the input (minimum of the matrix dimensions). If not, the vector will automatically be resized.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </p>

</div>
</div>
<a id="a4ce8a4749274cec16f928d2037e7bacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce8a4749274cec16f928d2037e7bacf">&#9670;&nbsp;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the diagonal entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The diagonal. Length should match the length of the diagonal of the input (minimum of the matrix dimensions). If not, the vector will automatically be resized.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </p>

</div>
</div>
<a id="a3dd1d1e634440e01113a52c13f4600ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1d1e634440e01113a52c13f4600ae">&#9670;&nbsp;</a></span>fill_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::fill_diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries of the matrix to those in the vector. </p>
<p>If the vector is smaller than the matrix diagonal, the vector will recycle until the matrix diagonal is filled. If the vector is longer, then not all of it will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector of values to set the matrix diagonal to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81237f19ed4e258fc52f7fc5e3eae68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81237f19ed4e258fc52f7fc5e3eae68f">&#9670;&nbsp;</a></span>fill_linspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::fill_linspace </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set values to linearly spaced numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start,stop</td><td>Beginning/ending numbers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64a49cf368cbaf985e6b6d02fcf2eddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a49cf368cbaf985e6b6d02fcf2eddc">&#9670;&nbsp;</a></span>fill_rnorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::fill_rnorm </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sd</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>Seed for the rng. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean,sd</td><td>Parameters for the generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187ad255fd5eafd80e22c239f1ce59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187ad255fd5eafd80e22c239f1ce59ed">&#9670;&nbsp;</a></span>fill_runif()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::fill_runif </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>min</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>Seed for the rng. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min,max</td><td>Parameters for the generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6729880f298d58de70fa22dd05ae80e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6729880f298d58de70fa22dd05ae80e5">&#9670;&nbsp;</a></span>fill_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::fill_val </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values to input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value to set all data values to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a277d0f6a183df63ea1fea36c0523f1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277d0f6a183df63ea1fea36c0523f1eb">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the desired value, 0-indexed. The numbering considers the internal storage as a 1-dimensional array.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </p>

</div>
</div>
<a id="a55b4ddb2386c786a27db44b999c878bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4ddb2386c786a27db44b999c878bf">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i,j</td><td>The indices of the desired value, 0-indexed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </p>

</div>
</div>
<a id="a321eb5acfb80c659a1ca3fb54d4b2da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321eb5acfb80c659a1ca3fb54d4b2da9">&#9670;&nbsp;</a></span>get_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::get_col </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The desired column, 0-indexed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The column values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If <code>j</code> is an inappropriate value (i.e. does not refer to a matrix column), then the method will throw a <code>logic_error</code> exception. If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </p>

</div>
</div>
<a id="af56709907678a3a73bc25b09780c8837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56709907678a3a73bc25b09780c8837">&#9670;&nbsp;</a></span>get_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The desired row, 0-indexed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The row values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If <code>i</code> is an inappropriate value (i.e. does not refer to a matrix row), then the method will throw a <code>logic_error</code> exception. If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </p>

</div>
</div>
<a id="a3335dc81a02a28d5c29d5a964d7e1a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3335dc81a02a28d5c29d5a964d7e1a54">&#9670;&nbsp;</a></span>inherit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::inherit </td>
          <td>(</td>
          <td class="paramtype">REAL *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destruct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal object storage to the specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Value storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the matrix. The product of these should be the length of the input <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_on_destruct</td><td>Should the object destructor free the internal array <code>data</code>?</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </p>

</div>
</div>
<a id="a488f5f9d4d70da7e107a13b3017f9ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488f5f9d4d70da7e107a13b3017f9ca0">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the two objects are not the same. Uses same internal logic as the <code>==</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Comparison</td><td>object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12887b66ab784ca6d26b52a967091eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12887b66ab784ca6d26b52a967091eff">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt; &amp; <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator that sets the LHS to a shallow copy of the input. Desctruction of the LHS object will not result in the internal array storage being freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Setter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3171e0d622bd18a7255860e0fe55c4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3171e0d622bd18a7255860e0fe55c4d7">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the two objects are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Comparison</td><td>object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the dimensions mismatch, then <code>false</code> is necessarily returned. Next, if the pointer to the internal storage arrays match, then <code>true</code> is necessarily returned. Otherwise the objects are compared value by value. </dd></dl>

</div>
</div>
<a id="aa3efe331b1ee362489fad7a9e20e4db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3efe331b1ee362489fad7a9e20e4db3">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::print </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ndigits</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_final_blank</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print all values in the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of decimal digits to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_final_blank</td><td>Should a final blank line be printed? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad73dece47634d7372a38b27207c74a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73dece47634d7372a38b27207c74a2d">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the internal object storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns needed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 Resizing triggers a re-allocation.</p>
<p><b>Exceptions</b><br  />
 If the reallocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </p>

</div>
</div>
<a id="a7567afa9f0783601834bdff4bebe4bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7567afa9f0783601834bdff4bebe4bdb">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply all values by the input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Scaling value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e8ccf192ffa7ce15a63ba3610ba740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e8ccf192ffa7ce15a63ba3610ba740">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the storage at the specified index with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i,j</td><td>The indices of the desired value, 0-indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </p>

</div>
</div>
<a id="a49fc5c1fcc0a1276d778539ad6298abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fc5c1fcc0a1276d778539ad6298abb">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1cpumat.html">fml::cpumat</a>&lt; REAL &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the storage at the specified index with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the desired value, 0-indexed. The numbering considers the internal storage as a 1-dimensional array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>fml/src/fml/cpu/<a class="el" href="cpumat_8hh_source.html">cpumat.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefml.html">fml</a></li><li class="navelem"><a class="el" href="classfml_1_1cpumat.html">cpumat</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
