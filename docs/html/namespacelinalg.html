<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fml: linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fml_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fml
   &#160;<span id="projectnumber">0.1-0</span>
   </div>
   <div id="projectbrief">Fused Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelinalg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a63b1e768c0523aa04f8ef893b9205e44"><td class="memTemplParams" colspan="2"><a id="a63b1e768c0523aa04f8ef893b9205e44"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a63b1e768c0523aa04f8ef893b9205e44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="separator:a63b1e768c0523aa04f8ef893b9205e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0960f9520a6c5af2198ec0eb710d23"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9e0960f9520a6c5af2198ec0eb710d23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9e0960f9520a6c5af2198ec0eb710d23">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a9e0960f9520a6c5af2198ec0eb710d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="#a9e0960f9520a6c5af2198ec0eb710d23">More...</a><br /></td></tr>
<tr class="separator:a9e0960f9520a6c5af2198ec0eb710d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8276f93d5ae70c246a32a17ac236687"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab8276f93d5ae70c246a32a17ac236687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab8276f93d5ae70c246a32a17ac236687">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="separator:ab8276f93d5ae70c246a32a17ac236687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be4663a5995ebc6438b880a2a2a36c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a46be4663a5995ebc6438b880a2a2a36c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a46be4663a5995ebc6438b880a2a2a36c">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a46be4663a5995ebc6438b880a2a2a36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="#a46be4663a5995ebc6438b880a2a2a36c">More...</a><br /></td></tr>
<tr class="separator:a46be4663a5995ebc6438b880a2a2a36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42d2fe70ae468a1e56d83598d34d55c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac42d2fe70ae468a1e56d83598d34d55c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ac42d2fe70ae468a1e56d83598d34d55c">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ac42d2fe70ae468a1e56d83598d34d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="#ac42d2fe70ae468a1e56d83598d34d55c">More...</a><br /></td></tr>
<tr class="separator:ac42d2fe70ae468a1e56d83598d34d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be4ebb992a8574455962c8d894562dd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5be4ebb992a8574455962c8d894562dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5be4ebb992a8574455962c8d894562dd">crossprod</a> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a5be4ebb992a8574455962c8d894562dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="#a5be4ebb992a8574455962c8d894562dd">More...</a><br /></td></tr>
<tr class="separator:a5be4ebb992a8574455962c8d894562dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ae42a6ed2c4da0fc01d09baeb126f4ee5">crossprod</a> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bafc46faba643f53c56ca8d7d9f224"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab0bafc46faba643f53c56ca8d7d9f224"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab0bafc46faba643f53c56ca8d7d9f224">tcrossprod</a> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ab0bafc46faba643f53c56ca8d7d9f224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="#ab0bafc46faba643f53c56ca8d7d9f224">More...</a><br /></td></tr>
<tr class="separator:ab0bafc46faba643f53c56ca8d7d9f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d9c14e352a4bcd4df674388bf76bf2"><td class="memTemplParams" colspan="2"><a id="a67d9c14e352a4bcd4df674388bf76bf2"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a67d9c14e352a4bcd4df674388bf76bf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tcrossprod</b> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a67d9c14e352a4bcd4df674388bf76bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38aa5c66c35f4c9200646f86cbac9783"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a38aa5c66c35f4c9200646f86cbac9783"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a38aa5c66c35f4c9200646f86cbac9783">xpose</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:a38aa5c66c35f4c9200646f86cbac9783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="#a38aa5c66c35f4c9200646f86cbac9783">More...</a><br /></td></tr>
<tr class="separator:a38aa5c66c35f4c9200646f86cbac9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9608507fe1023547afad28ddc1d0770"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa9608507fe1023547afad28ddc1d0770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa9608507fe1023547afad28ddc1d0770">xpose</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:aa9608507fe1023547afad28ddc1d0770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936cd2444d3cc74c4623dedbbc9452ce"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a936cd2444d3cc74c4623dedbbc9452ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a936cd2444d3cc74c4623dedbbc9452ce">lu</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a936cd2444d3cc74c4623dedbbc9452ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="#a936cd2444d3cc74c4623dedbbc9452ce">More...</a><br /></td></tr>
<tr class="separator:a936cd2444d3cc74c4623dedbbc9452ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcb751466f2d2b6c49efc117b987ba8"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8fcb751466f2d2b6c49efc117b987ba8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a8fcb751466f2d2b6c49efc117b987ba8">lu</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a8fcb751466f2d2b6c49efc117b987ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1203ef54c7f115eebe5ac9905931542"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa1203ef54c7f115eebe5ac9905931542"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa1203ef54c7f115eebe5ac9905931542">trace</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aa1203ef54c7f115eebe5ac9905931542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="#aa1203ef54c7f115eebe5ac9905931542">More...</a><br /></td></tr>
<tr class="separator:aa1203ef54c7f115eebe5ac9905931542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9f4d0b000f21e016aed2bd326e1a12"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aff9f4d0b000f21e016aed2bd326e1a12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12">svd</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:aff9f4d0b000f21e016aed2bd326e1a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="#aff9f4d0b000f21e016aed2bd326e1a12">More...</a><br /></td></tr>
<tr class="separator:aff9f4d0b000f21e016aed2bd326e1a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a2fb03e4ac9901d98eaade9a4a1bfe8b2">svd</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="separator:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659a4e16f32fda53611d7c9f1623e44"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3659a4e16f32fda53611d7c9f1623e44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3659a4e16f32fda53611d7c9f1623e44">eigen_sym</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a3659a4e16f32fda53611d7c9f1623e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="#a3659a4e16f32fda53611d7c9f1623e44">More...</a><br /></td></tr>
<tr class="separator:a3659a4e16f32fda53611d7c9f1623e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b9dd202f9418c8847e78596153098"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab74b9dd202f9418c8847e78596153098"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab74b9dd202f9418c8847e78596153098">eigen_sym</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="separator:ab74b9dd202f9418c8847e78596153098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a61c2f7a9a68e276c55af4abdcd69f94f">invert</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="#a61c2f7a9a68e276c55af4abdcd69f94f">More...</a><br /></td></tr>
<tr class="separator:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5ef3bf18806056a87fcd4df9fb013bd6">solve</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="#a5ef3bf18806056a87fcd4df9fb013bd6">More...</a><br /></td></tr>
<tr class="separator:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65971967708b68aa071e0b4e25c400a6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a65971967708b68aa071e0b4e25c400a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a65971967708b68aa071e0b4e25c400a6">solve</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="separator:a65971967708b68aa071e0b4e25c400a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598dd44fc1f348c662311a5996e4fab"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4598dd44fc1f348c662311a5996e4fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a4598dd44fc1f348c662311a5996e4fab">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a4598dd44fc1f348c662311a5996e4fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="#a4598dd44fc1f348c662311a5996e4fab">More...</a><br /></td></tr>
<tr class="separator:a4598dd44fc1f348c662311a5996e4fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e37f0ce00a99e19f69c0c790f21e684"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a7e37f0ce00a99e19f69c0c790f21e684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a7e37f0ce00a99e19f69c0c790f21e684">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="separator:a7e37f0ce00a99e19f69c0c790f21e684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faad9695d8ba603eb2fcf35b001f755"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2faad9695d8ba603eb2fcf35b001f755"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a2faad9695d8ba603eb2fcf35b001f755">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a2faad9695d8ba603eb2fcf35b001f755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="#a2faad9695d8ba603eb2fcf35b001f755">More...</a><br /></td></tr>
<tr class="separator:a2faad9695d8ba603eb2fcf35b001f755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf89e8891a6a10497a65fc4a1daa201"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aadf89e8891a6a10497a65fc4a1daa201"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aadf89e8891a6a10497a65fc4a1daa201">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:aadf89e8891a6a10497a65fc4a1daa201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="#aadf89e8891a6a10497a65fc4a1daa201">More...</a><br /></td></tr>
<tr class="separator:aadf89e8891a6a10497a65fc4a1daa201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92081bd5c471afb7ef30c78d894db97a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a92081bd5c471afb7ef30c78d894db97a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a92081bd5c471afb7ef30c78d894db97a">crossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a92081bd5c471afb7ef30c78d894db97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="#a92081bd5c471afb7ef30c78d894db97a">More...</a><br /></td></tr>
<tr class="separator:a92081bd5c471afb7ef30c78d894db97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae220218e85361fa2e2c06e9de9e61c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:adae220218e85361fa2e2c06e9de9e61c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#adae220218e85361fa2e2c06e9de9e61c">crossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:adae220218e85361fa2e2c06e9de9e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3c1fa0494b43c5cd2a83b52e1f7a06fc">tcrossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="#a3c1fa0494b43c5cd2a83b52e1f7a06fc">More...</a><br /></td></tr>
<tr class="separator:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa7a6eb25d0c22df7962c9f9305cf8c80">tcrossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ad6f65f84ac39f9d688a49dfb4bd5c1f7">xpose</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="#ad6f65f84ac39f9d688a49dfb4bd5c1f7">More...</a><br /></td></tr>
<tr class="separator:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03c48700965e927bd95cff4c1141840"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af03c48700965e927bd95cff4c1141840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af03c48700965e927bd95cff4c1141840">xpose</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:af03c48700965e927bd95cff4c1141840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12807dd969487fb835563c9998120beb"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a12807dd969487fb835563c9998120beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a12807dd969487fb835563c9998120beb">lu</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a12807dd969487fb835563c9998120beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="#a12807dd969487fb835563c9998120beb">More...</a><br /></td></tr>
<tr class="separator:a12807dd969487fb835563c9998120beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f882607a9ba5e1b8d772b25fcead0d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af4f882607a9ba5e1b8d772b25fcead0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af4f882607a9ba5e1b8d772b25fcead0d">lu</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:af4f882607a9ba5e1b8d772b25fcead0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e00c8ab31fc607ea4978ece08612f9"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a44e00c8ab31fc607ea4978ece08612f9"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a44e00c8ab31fc607ea4978ece08612f9">trace</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a44e00c8ab31fc607ea4978ece08612f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="#a44e00c8ab31fc607ea4978ece08612f9">More...</a><br /></td></tr>
<tr class="separator:a44e00c8ab31fc607ea4978ece08612f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eac5c2d50bb27d713f3e435e1159def"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9eac5c2d50bb27d713f3e435e1159def"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9eac5c2d50bb27d713f3e435e1159def">svd</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a9eac5c2d50bb27d713f3e435e1159def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="#a9eac5c2d50bb27d713f3e435e1159def">More...</a><br /></td></tr>
<tr class="separator:a9eac5c2d50bb27d713f3e435e1159def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af113b72e5d1d3c40fb732d4e22bb781a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af113b72e5d1d3c40fb732d4e22bb781a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af113b72e5d1d3c40fb732d4e22bb781a">svd</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="separator:af113b72e5d1d3c40fb732d4e22bb781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5e0babfee3b0f077701529f683b43"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a0ac5e0babfee3b0f077701529f683b43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a0ac5e0babfee3b0f077701529f683b43">eigen_sym</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a0ac5e0babfee3b0f077701529f683b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="#a0ac5e0babfee3b0f077701529f683b43">More...</a><br /></td></tr>
<tr class="separator:a0ac5e0babfee3b0f077701529f683b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0860419eeabd495aabfd114f05e3227"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac0860419eeabd495aabfd114f05e3227"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ac0860419eeabd495aabfd114f05e3227">eigen_sym</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="separator:ac0860419eeabd495aabfd114f05e3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb829c79675afc6746bbf2702332455"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9bb829c79675afc6746bbf2702332455"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9bb829c79675afc6746bbf2702332455">invert</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a9bb829c79675afc6746bbf2702332455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="#a9bb829c79675afc6746bbf2702332455">More...</a><br /></td></tr>
<tr class="separator:a9bb829c79675afc6746bbf2702332455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f60d21486ed1a4ceeefa657d0123673"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5f60d21486ed1a4ceeefa657d0123673"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5f60d21486ed1a4ceeefa657d0123673">solve</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a5f60d21486ed1a4ceeefa657d0123673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="#a5f60d21486ed1a4ceeefa657d0123673">More...</a><br /></td></tr>
<tr class="separator:a5f60d21486ed1a4ceeefa657d0123673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec10ae7fc07d5e5943efce2505103f3"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5ec10ae7fc07d5e5943efce2505103f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5ec10ae7fc07d5e5943efce2505103f3">solve</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="separator:a5ec10ae7fc07d5e5943efce2505103f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715efcba095fd432b87ab6c1db54ea9d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a715efcba095fd432b87ab6c1db54ea9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a715efcba095fd432b87ab6c1db54ea9d">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a715efcba095fd432b87ab6c1db54ea9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="#a715efcba095fd432b87ab6c1db54ea9d">More...</a><br /></td></tr>
<tr class="separator:a715efcba095fd432b87ab6c1db54ea9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a31fb7ea71170ac4c1d42d1dd88215bdb">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="separator:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa00d3b1a47a6b84fbd48defb75fe1545">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="#aa00d3b1a47a6b84fbd48defb75fe1545">More...</a><br /></td></tr>
<tr class="separator:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667be52cee94da7dac6cf9b15c54eea4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a667be52cee94da7dac6cf9b15c54eea4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a667be52cee94da7dac6cf9b15c54eea4">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a667be52cee94da7dac6cf9b15c54eea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="#a667be52cee94da7dac6cf9b15c54eea4">More...</a><br /></td></tr>
<tr class="separator:a667be52cee94da7dac6cf9b15c54eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d8becf273135de34f2b20568e361"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af760d8becf273135de34f2b20568e361"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af760d8becf273135de34f2b20568e361">crossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:af760d8becf273135de34f2b20568e361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="#af760d8becf273135de34f2b20568e361">More...</a><br /></td></tr>
<tr class="separator:af760d8becf273135de34f2b20568e361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d706716a5be9e5a3931fbeff7816e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a614d706716a5be9e5a3931fbeff7816e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a614d706716a5be9e5a3931fbeff7816e">crossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a614d706716a5be9e5a3931fbeff7816e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e93959b15e348ce1cc0324955a7908b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3e93959b15e348ce1cc0324955a7908b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3e93959b15e348ce1cc0324955a7908b">tcrossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a3e93959b15e348ce1cc0324955a7908b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="#a3e93959b15e348ce1cc0324955a7908b">More...</a><br /></td></tr>
<tr class="separator:a3e93959b15e348ce1cc0324955a7908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64867420c54679a013dc91e3c3b7c6c9"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a64867420c54679a013dc91e3c3b7c6c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a64867420c54679a013dc91e3c3b7c6c9">tcrossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a64867420c54679a013dc91e3c3b7c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36f54cbabde4d6488c4dca65b87926"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1d36f54cbabde4d6488c4dca65b87926"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a1d36f54cbabde4d6488c4dca65b87926">xpose</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:a1d36f54cbabde4d6488c4dca65b87926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="#a1d36f54cbabde4d6488c4dca65b87926">More...</a><br /></td></tr>
<tr class="separator:a1d36f54cbabde4d6488c4dca65b87926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d167ddd24b88513a250088dcaf428b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a12d167ddd24b88513a250088dcaf428b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a12d167ddd24b88513a250088dcaf428b">xpose</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a12d167ddd24b88513a250088dcaf428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c1f61e19df98acdabc6fe26c8c03b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a640c1f61e19df98acdabc6fe26c8c03b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a640c1f61e19df98acdabc6fe26c8c03b">lu</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a640c1f61e19df98acdabc6fe26c8c03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="#a640c1f61e19df98acdabc6fe26c8c03b">More...</a><br /></td></tr>
<tr class="separator:a640c1f61e19df98acdabc6fe26c8c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0a401d4326e44d985c750f367792df"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ace0a401d4326e44d985c750f367792df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ace0a401d4326e44d985c750f367792df">lu</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:ace0a401d4326e44d985c750f367792df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00835947de924651a2dec07f98ff5d1b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a00835947de924651a2dec07f98ff5d1b"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a00835947de924651a2dec07f98ff5d1b">trace</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a00835947de924651a2dec07f98ff5d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="#a00835947de924651a2dec07f98ff5d1b">More...</a><br /></td></tr>
<tr class="separator:a00835947de924651a2dec07f98ff5d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd6bce42acd5d23069863a6e7e623a4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:accd6bce42acd5d23069863a6e7e623a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#accd6bce42acd5d23069863a6e7e623a4">svd</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:accd6bce42acd5d23069863a6e7e623a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="#accd6bce42acd5d23069863a6e7e623a4">More...</a><br /></td></tr>
<tr class="separator:accd6bce42acd5d23069863a6e7e623a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab735b1be6cc7427db9c8c062e4e0ee51">svd</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="separator:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e24c473ff21f6abef9af5c730b07fb2"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8e24c473ff21f6abef9af5c730b07fb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a8e24c473ff21f6abef9af5c730b07fb2">eigen_sym</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a8e24c473ff21f6abef9af5c730b07fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="#a8e24c473ff21f6abef9af5c730b07fb2">More...</a><br /></td></tr>
<tr class="separator:a8e24c473ff21f6abef9af5c730b07fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8235a0717a937576fbb4d7e705214"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a10e8235a0717a937576fbb4d7e705214"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a10e8235a0717a937576fbb4d7e705214">eigen_sym</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="separator:a10e8235a0717a937576fbb4d7e705214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6444a6317f337b8b4bfc3ece04c836c1"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6444a6317f337b8b4bfc3ece04c836c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a6444a6317f337b8b4bfc3ece04c836c1">invert</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a6444a6317f337b8b4bfc3ece04c836c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="#a6444a6317f337b8b4bfc3ece04c836c1">More...</a><br /></td></tr>
<tr class="separator:a6444a6317f337b8b4bfc3ece04c836c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94568ee6fe3627e1799e7d614d7cd6e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af94568ee6fe3627e1799e7d614d7cd6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af94568ee6fe3627e1799e7d614d7cd6e">solve</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:af94568ee6fe3627e1799e7d614d7cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="#af94568ee6fe3627e1799e7d614d7cd6e">More...</a><br /></td></tr>
<tr class="separator:af94568ee6fe3627e1799e7d614d7cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="memTemplParams" colspan="2"><a id="ac00eeb5ca75d6aa1110a7b64bd5d429f"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ac00eeb5ca75d6aa1110a7b64bd5d429f">crossprod</a> (const REAL alpha, const <a class="el" href="classparmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x. <br /></td></tr>
<tr class="separator:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3c6302168d97b0d4d36caca4666b47"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9a3c6302168d97b0d4d36caca4666b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9a3c6302168d97b0d4d36caca4666b47">crossprod</a> (const REAL alpha, const <a class="el" href="classparmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a9a3c6302168d97b0d4d36caca4666b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e0960f9520a6c5af2198ec0eb710d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0960f9520a6c5af2198ec0eb710d23">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for the sum, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715efcba095fd432b87ab6c1db54ea9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715efcba095fd432b87ab6c1db54ea9d">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for the sum, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the PBLAS function <code>pXgeadd()</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4598dd44fc1f348c662311a5996e4fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4598dd44fc1f348c662311a5996e4fab">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for the sum, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuBLAS function <code>cublasXgeam()</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31fb7ea71170ac4c1d42d1dd88215bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fb7ea71170ac4c1d42d1dd88215bdb">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpimat.html">mpimat</a>&lt;REAL&gt; linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7e37f0ce00a99e19f69c0c790f21e684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e37f0ce00a99e19f69c0c790f21e684">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt;REAL&gt; linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab8276f93d5ae70c246a32a17ac236687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8276f93d5ae70c246a32a17ac236687">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpumat.html">cpumat</a>&lt;REAL&gt; linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9a3c6302168d97b0d4d36caca4666b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3c6302168d97b0d4d36caca4666b47">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpumat.html">cpumat</a>&lt;REAL&gt; linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classparmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a92081bd5c471afb7ef30c78d894db97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92081bd5c471afb7ef30c78d894db97a">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuBLAS function <code>cublasXsyrk()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af760d8becf273135de34f2b20568e361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760d8becf273135de34f2b20568e361">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the BLAS function <code>pXsyrk()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details</dt><dd>The method will communicate across all processes in the BLACS grid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be4ebb992a8574455962c8d894562dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be4ebb992a8574455962c8d894562dd">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the BLAS function <code>Xsyrk()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614d706716a5be9e5a3931fbeff7816e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614d706716a5be9e5a3931fbeff7816e">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpimat.html">mpimat</a>&lt;REAL&gt; linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="adae220218e85361fa2e2c06e9de9e61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae220218e85361fa2e2c06e9de9e61c">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt;REAL&gt; linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae42a6ed2c4da0fc01d09baeb126f4ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42a6ed2c4da0fc01d09baeb126f4ee5">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpumat.html">cpumat</a>&lt;REAL&gt; linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3659a4e16f32fda53611d7c9f1623e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3659a4e16f32fda53611d7c9f1623e44">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the LAPACK functions <code>Xsyevr()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If any output's dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e24c473ff21f6abef9af5c730b07fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e24c473ff21f6abef9af5c730b07fb2">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the ScaLAPACK functions <code>pXsyevr()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If any output's dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74b9dd202f9418c8847e78596153098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74b9dd202f9418c8847e78596153098">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a10e8235a0717a937576fbb4d7e705214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e8235a0717a937576fbb4d7e705214">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0ac5e0babfee3b0f077701529f683b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac5e0babfee3b0f077701529f683b43">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuSOLVER functions <code>cusolverDnXsyevd()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If any output's dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0860419eeabd495aabfd114f05e3227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0860419eeabd495aabfd114f05e3227">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a61c2f7a9a68e276c55af4abdcd69f94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c2f7a9a68e276c55af4abdcd69f94f">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the LAPACK functions <code>Xgetrf()</code> (LU) and <code>Xgetri()</code> (solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>LU pivot data is allocated internally.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6444a6317f337b8b4bfc3ece04c836c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6444a6317f337b8b4bfc3ece04c836c1">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the ScaLAPACK functions <code>pXgetrf()</code> (LU) and <code>pXgetri()</code> (solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>LU pivot data is allocated internally.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bb829c79675afc6746bbf2702332455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb829c79675afc6746bbf2702332455">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuSOLVER functions <code>cusolverDnXgetrf()</code> (LU) and <code>cusolverDnXgetrs()</code> (solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>LU pivot data is allocated internally. The inverse is computed in a copy before copying back to the input.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a640c1f61e19df98acdabc6fe26c8c03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640c1f61e19df98acdabc6fe26c8c03b">&#9670;&nbsp;</a></span>lu() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the ScaLAPACK function <code>pXgetrf()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the pivot vector is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12807dd969487fb835563c9998120beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12807dd969487fb835563c9998120beb">&#9670;&nbsp;</a></span>lu() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuSOLVER function <code>cusolverDnXgetrf()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the pivot vector is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a936cd2444d3cc74c4623dedbbc9452ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936cd2444d3cc74c4623dedbbc9452ce">&#9670;&nbsp;</a></span>lu() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the LAPACK function <code>Xgetrf()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the pivot vector is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace0a401d4326e44d985c750f367792df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0a401d4326e44d985c750f367792df">&#9670;&nbsp;</a></span>lu() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8fcb751466f2d2b6c49efc117b987ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcb751466f2d2b6c49efc117b987ba8">&#9670;&nbsp;</a></span>lu() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af4f882607a9ba5e1b8d772b25fcead0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f882607a9ba5e1b8d772b25fcead0d">&#9670;&nbsp;</a></span>lu() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa00d3b1a47a6b84fbd48defb75fe1545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00d3b1a47a6b84fbd48defb75fe1545">&#9670;&nbsp;</a></span>matmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpimat.html">mpimat</a>&lt;REAL&gt; linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the PBLAS function <code>pXgemm()</code>.</dd></dl>
<dl class="section user"><dt>Communication Details</dt><dd>The method will communicate across all processes in the BLACS grid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2faad9695d8ba603eb2fcf35b001f755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faad9695d8ba603eb2fcf35b001f755">&#9670;&nbsp;</a></span>matmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt;REAL&gt; linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuBLAS function <code>cublasXgemm()</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46be4663a5995ebc6438b880a2a2a36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46be4663a5995ebc6438b880a2a2a36c">&#9670;&nbsp;</a></span>matmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpumat.html">cpumat</a>&lt;REAL&gt; linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the BLAS function <code>Xgemm()</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadf89e8891a6a10497a65fc4a1daa201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf89e8891a6a10497a65fc4a1daa201">&#9670;&nbsp;</a></span>matmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuBLAS function <code>cublasXgemm()</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a667be52cee94da7dac6cf9b15c54eea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667be52cee94da7dac6cf9b15c54eea4">&#9670;&nbsp;</a></span>matmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the PBLAS function <code>pXgemm()</code>.</dd></dl>
<dl class="section user"><dt>Communication Details</dt><dd>The method will communicate across all processes in the BLACS grid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42d2fe70ae468a1e56d83598d34d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42d2fe70ae468a1e56d83598d34d55c">&#9670;&nbsp;</a></span>matmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the BLAS function <code>Xgemm()</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af94568ee6fe3627e1799e7d614d7cd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94568ee6fe3627e1799e7d614d7cd6e">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the LAPACK functions <code>pXgesv()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>LU pivot data is allocated internally.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square or if the RHS is incompatible with the LHS, a <code>runtime_error</code> exception is thrown. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ef3bf18806056a87fcd4df9fb013bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef3bf18806056a87fcd4df9fb013bd6">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the LAPACK functions <code>Xgesv()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>LU pivot data is allocated internally.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square or if the RHS is incompatible with the LHS, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65971967708b68aa071e0b4e25c400a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65971967708b68aa071e0b4e25c400a6">&#9670;&nbsp;</a></span>solve() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5f60d21486ed1a4ceeefa657d0123673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f60d21486ed1a4ceeefa657d0123673">&#9670;&nbsp;</a></span>solve() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its PLU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuSOLVER functions <code>cusolverDnXgetrf()</code> (LU) and <code>cusolverDnXgetrs()</code> (solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>LU pivot data is allocated internally.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the matrix is non-square or if the RHS is incompatible with the LHS, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec10ae7fc07d5e5943efce2505103f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec10ae7fc07d5e5943efce2505103f3">&#9670;&nbsp;</a></span>solve() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aff9f4d0b000f21e016aed2bd326e1a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9f4d0b000f21e016aed2bd326e1a12">&#9670;&nbsp;</a></span>svd() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singnular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the LAPACK function <code>Xgesvd()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd6bce42acd5d23069863a6e7e623a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd6bce42acd5d23069863a6e7e623a4">&#9670;&nbsp;</a></span>svd() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singnular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the ScaLAPACK function <code>pXgesvd()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fb03e4ac9901d98eaade9a4a1bfe8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb03e4ac9901d98eaade9a4a1bfe8b2">&#9670;&nbsp;</a></span>svd() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab735b1be6cc7427db9c8c062e4e0ee51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab735b1be6cc7427db9c8c062e4e0ee51">&#9670;&nbsp;</a></span>svd() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9eac5c2d50bb27d713f3e435e1159def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eac5c2d50bb27d713f3e435e1159def">&#9670;&nbsp;</a></span>svd() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singnular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuSOLVER function <code>cusolverDnXgesvd()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af113b72e5d1d3c40fb732d4e22bb781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af113b72e5d1d3c40fb732d4e22bb781a">&#9670;&nbsp;</a></span>svd() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3c1fa0494b43c5cd2a83b52e1f7a06fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1fa0494b43c5cd2a83b52e1f7a06fc">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuBLAS function <code>cublasXsyrk()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e93959b15e348ce1cc0324955a7908b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e93959b15e348ce1cc0324955a7908b">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the PBLAS function <code>pXsyrk()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details</dt><dd>The method will communicate across all processes in the BLACS grid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0bafc46faba643f53c56ca8d7d9f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bafc46faba643f53c56ca8d7d9f224">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the BLAS function <code>Xsyrk()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64867420c54679a013dc91e3c3b7c6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64867420c54679a013dc91e3c3b7c6c9">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpimat.html">mpimat</a>&lt;REAL&gt; linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa7a6eb25d0c22df7962c9f9305cf8c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a6eb25d0c22df7962c9f9305cf8c80">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt;REAL&gt; linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a00835947de924651a2dec07f98ff5d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00835947de924651a2dec07f98ff5d1b">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Communication Details</dt><dd>The method will communicate across all processes in the BLACS grid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1203ef54c7f115eebe5ac9905931542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1203ef54c7f115eebe5ac9905931542">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44e00c8ab31fc607ea4978ece08612f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e00c8ab31fc607ea4978ece08612f9">&#9670;&nbsp;</a></span>trace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38aa5c66c35f4c9200646f86cbac9783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38aa5c66c35f4c9200646f86cbac9783">&#9670;&nbsp;</a></span>xpose() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d36f54cbabde4d6488c4dca65b87926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36f54cbabde4d6488c4dca65b87926">&#9670;&nbsp;</a></span>xpose() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the PBLAS function <code>pXtran()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f65f84ac39f9d688a49dfb4bd5c1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f65f84ac39f9d688a49dfb4bd5c1f7">&#9670;&nbsp;</a></span>xpose() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details</dt><dd>Uses the cuBLAS function <code>cublasXgeam()</code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12d167ddd24b88513a250088dcaf428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d167ddd24b88513a250088dcaf428b">&#9670;&nbsp;</a></span>xpose() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpimat.html">mpimat</a>&lt;REAL&gt; linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af03c48700965e927bd95cff4c1141840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03c48700965e927bd95cff4c1141840">&#9670;&nbsp;</a></span>xpose() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt;REAL&gt; linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa9608507fe1023547afad28ddc1d0770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9608507fe1023547afad28ddc1d0770">&#9670;&nbsp;</a></span>xpose() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpumat.html">cpumat</a>&lt;REAL&gt; linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelinalg.html">linalg</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
