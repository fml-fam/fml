<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fml: linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fml_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fml
   &#160;<span id="projectnumber">0.1-0</span>
   </div>
   <div id="projectbrief">Fused Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacelinalg.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra functions.  
<a href="namespacelinalg.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91543156f369691613c1334ccebe58b3"><td class="memTemplParams" colspan="2"><a id="a91543156f369691613c1334ccebe58b3"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a91543156f369691613c1334ccebe58b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rsvd</b> (const int k, const int q, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="separator:a91543156f369691613c1334ccebe58b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0960f9520a6c5af2198ec0eb710d23"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9e0960f9520a6c5af2198ec0eb710d23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9e0960f9520a6c5af2198ec0eb710d23">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a9e0960f9520a6c5af2198ec0eb710d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#a9e0960f9520a6c5af2198ec0eb710d23">More...</a><br /></td></tr>
<tr class="separator:a9e0960f9520a6c5af2198ec0eb710d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8276f93d5ae70c246a32a17ac236687"><td class="memTemplParams" colspan="2"><a id="ab8276f93d5ae70c246a32a17ac236687"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab8276f93d5ae70c246a32a17ac236687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab8276f93d5ae70c246a32a17ac236687">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ab8276f93d5ae70c246a32a17ac236687"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab8276f93d5ae70c246a32a17ac236687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be4663a5995ebc6438b880a2a2a36c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a46be4663a5995ebc6438b880a2a2a36c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a46be4663a5995ebc6438b880a2a2a36c">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a46be4663a5995ebc6438b880a2a2a36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#a46be4663a5995ebc6438b880a2a2a36c">More...</a><br /></td></tr>
<tr class="separator:a46be4663a5995ebc6438b880a2a2a36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42d2fe70ae468a1e56d83598d34d55c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac42d2fe70ae468a1e56d83598d34d55c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ac42d2fe70ae468a1e56d83598d34d55c">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ac42d2fe70ae468a1e56d83598d34d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#ac42d2fe70ae468a1e56d83598d34d55c">More...</a><br /></td></tr>
<tr class="separator:ac42d2fe70ae468a1e56d83598d34d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be4ebb992a8574455962c8d894562dd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5be4ebb992a8574455962c8d894562dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5be4ebb992a8574455962c8d894562dd">crossprod</a> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a5be4ebb992a8574455962c8d894562dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacelinalg.html#a5be4ebb992a8574455962c8d894562dd">More...</a><br /></td></tr>
<tr class="separator:a5be4ebb992a8574455962c8d894562dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="memTemplParams" colspan="2"><a id="ae42a6ed2c4da0fc01d09baeb126f4ee5"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ae42a6ed2c4da0fc01d09baeb126f4ee5">crossprod</a> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae42a6ed2c4da0fc01d09baeb126f4ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bafc46faba643f53c56ca8d7d9f224"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab0bafc46faba643f53c56ca8d7d9f224"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab0bafc46faba643f53c56ca8d7d9f224">tcrossprod</a> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ab0bafc46faba643f53c56ca8d7d9f224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="namespacelinalg.html#ab0bafc46faba643f53c56ca8d7d9f224">More...</a><br /></td></tr>
<tr class="separator:ab0bafc46faba643f53c56ca8d7d9f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d9c14e352a4bcd4df674388bf76bf2"><td class="memTemplParams" colspan="2"><a id="a67d9c14e352a4bcd4df674388bf76bf2"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a67d9c14e352a4bcd4df674388bf76bf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tcrossprod</b> (const REAL alpha, const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a67d9c14e352a4bcd4df674388bf76bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38aa5c66c35f4c9200646f86cbac9783"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a38aa5c66c35f4c9200646f86cbac9783"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a38aa5c66c35f4c9200646f86cbac9783">xpose</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:a38aa5c66c35f4c9200646f86cbac9783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="namespacelinalg.html#a38aa5c66c35f4c9200646f86cbac9783">More...</a><br /></td></tr>
<tr class="separator:a38aa5c66c35f4c9200646f86cbac9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9608507fe1023547afad28ddc1d0770"><td class="memTemplParams" colspan="2"><a id="aa9608507fe1023547afad28ddc1d0770"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa9608507fe1023547afad28ddc1d0770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa9608507fe1023547afad28ddc1d0770">xpose</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aa9608507fe1023547afad28ddc1d0770"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aa9608507fe1023547afad28ddc1d0770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936cd2444d3cc74c4623dedbbc9452ce"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a936cd2444d3cc74c4623dedbbc9452ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a936cd2444d3cc74c4623dedbbc9452ce">lu</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a936cd2444d3cc74c4623dedbbc9452ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="namespacelinalg.html#a936cd2444d3cc74c4623dedbbc9452ce">More...</a><br /></td></tr>
<tr class="separator:a936cd2444d3cc74c4623dedbbc9452ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcb751466f2d2b6c49efc117b987ba8"><td class="memTemplParams" colspan="2"><a id="a8fcb751466f2d2b6c49efc117b987ba8"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8fcb751466f2d2b6c49efc117b987ba8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a8fcb751466f2d2b6c49efc117b987ba8">lu</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a8fcb751466f2d2b6c49efc117b987ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a8fcb751466f2d2b6c49efc117b987ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b1e768c0523aa04f8ef893b9205e44"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a63b1e768c0523aa04f8ef893b9205e44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a63b1e768c0523aa04f8ef893b9205e44">det</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="memdesc:a63b1e768c0523aa04f8ef893b9205e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant in logarithmic form.  <a href="namespacelinalg.html#a63b1e768c0523aa04f8ef893b9205e44">More...</a><br /></td></tr>
<tr class="separator:a63b1e768c0523aa04f8ef893b9205e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1203ef54c7f115eebe5ac9905931542"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa1203ef54c7f115eebe5ac9905931542"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa1203ef54c7f115eebe5ac9905931542">trace</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aa1203ef54c7f115eebe5ac9905931542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="namespacelinalg.html#aa1203ef54c7f115eebe5ac9905931542">More...</a><br /></td></tr>
<tr class="separator:aa1203ef54c7f115eebe5ac9905931542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9f4d0b000f21e016aed2bd326e1a12"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aff9f4d0b000f21e016aed2bd326e1a12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12">svd</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:aff9f4d0b000f21e016aed2bd326e1a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12">More...</a><br /></td></tr>
<tr class="separator:aff9f4d0b000f21e016aed2bd326e1a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="memTemplParams" colspan="2"><a id="a2fb03e4ac9901d98eaade9a4a1bfe8b2"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a2fb03e4ac9901d98eaade9a4a1bfe8b2">svd</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a2fb03e4ac9901d98eaade9a4a1bfe8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659a4e16f32fda53611d7c9f1623e44"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3659a4e16f32fda53611d7c9f1623e44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3659a4e16f32fda53611d7c9f1623e44">eigen_sym</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a3659a4e16f32fda53611d7c9f1623e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="namespacelinalg.html#a3659a4e16f32fda53611d7c9f1623e44">More...</a><br /></td></tr>
<tr class="separator:a3659a4e16f32fda53611d7c9f1623e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b9dd202f9418c8847e78596153098"><td class="memTemplParams" colspan="2"><a id="ab74b9dd202f9418c8847e78596153098"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab74b9dd202f9418c8847e78596153098"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab74b9dd202f9418c8847e78596153098">eigen_sym</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="memdesc:ab74b9dd202f9418c8847e78596153098"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab74b9dd202f9418c8847e78596153098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a61c2f7a9a68e276c55af4abdcd69f94f">invert</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="namespacelinalg.html#a61c2f7a9a68e276c55af4abdcd69f94f">More...</a><br /></td></tr>
<tr class="separator:a61c2f7a9a68e276c55af4abdcd69f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5ef3bf18806056a87fcd4df9fb013bd6">solve</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="namespacelinalg.html#a5ef3bf18806056a87fcd4df9fb013bd6">More...</a><br /></td></tr>
<tr class="separator:a5ef3bf18806056a87fcd4df9fb013bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65971967708b68aa071e0b4e25c400a6"><td class="memTemplParams" colspan="2"><a id="a65971967708b68aa071e0b4e25c400a6"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a65971967708b68aa071e0b4e25c400a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a65971967708b68aa071e0b4e25c400a6">solve</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a65971967708b68aa071e0b4e25c400a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a65971967708b68aa071e0b4e25c400a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a24f47163185b7f9beca140de15228"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa1a24f47163185b7f9beca140de15228"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228">qr</a> (const bool pivot, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux)</td></tr>
<tr class="memdesc:aa1a24f47163185b7f9beca140de15228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR decomposition.  <a href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228">More...</a><br /></td></tr>
<tr class="separator:aa1a24f47163185b7f9beca140de15228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf79fca7662571560c744b4902edbff"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9cf79fca7662571560c744b4902edbff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9cf79fca7662571560c744b4902edbff">qr_Q</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;QR, const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a9cf79fca7662571560c744b4902edbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a QR decomposition.  <a href="namespacelinalg.html#a9cf79fca7662571560c744b4902edbff">More...</a><br /></td></tr>
<tr class="separator:a9cf79fca7662571560c744b4902edbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103917c1951078e6d485018c8849d814"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a103917c1951078e6d485018c8849d814"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a103917c1951078e6d485018c8849d814">qr_R</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;QR, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="memdesc:a103917c1951078e6d485018c8849d814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the R matrix from a QR decomposition.  <a href="namespacelinalg.html#a103917c1951078e6d485018c8849d814">More...</a><br /></td></tr>
<tr class="separator:a103917c1951078e6d485018c8849d814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fed51341966acce371a99cf7500d69"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a48fed51341966acce371a99cf7500d69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69">lq</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux)</td></tr>
<tr class="memdesc:a48fed51341966acce371a99cf7500d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LQ decomposition.  <a href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69">More...</a><br /></td></tr>
<tr class="separator:a48fed51341966acce371a99cf7500d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc17ae91a41777545e424bf8d4cd8a3c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:abc17ae91a41777545e424bf8d4cd8a3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#abc17ae91a41777545e424bf8d4cd8a3c">lq_L</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;LQ, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;L)</td></tr>
<tr class="memdesc:abc17ae91a41777545e424bf8d4cd8a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the L matrix from an LQ decomposition.  <a href="namespacelinalg.html#abc17ae91a41777545e424bf8d4cd8a3c">More...</a><br /></td></tr>
<tr class="separator:abc17ae91a41777545e424bf8d4cd8a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ad48f5ceb5b612451200befe82038a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af6ad48f5ceb5b612451200befe82038a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af6ad48f5ceb5b612451200befe82038a">lq_Q</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;LQ, const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:af6ad48f5ceb5b612451200befe82038a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from an LQ decomposition.  <a href="namespacelinalg.html#af6ad48f5ceb5b612451200befe82038a">More...</a><br /></td></tr>
<tr class="separator:af6ad48f5ceb5b612451200befe82038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426af0c3d82609472e27825ef4ff8bf6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a426af0c3d82609472e27825ef4ff8bf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a426af0c3d82609472e27825ef4ff8bf6">tssvd</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a426af0c3d82609472e27825ef4ff8bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition for tall/skinny data. The number of rows must be greater than the number of columns. If the number of rows is not significantly larger than the number of columns, this may not be more efficient than simply calling <code><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12" title="Computes the singular value decomposition.">linalg::svd()</a></code>.  <a href="namespacelinalg.html#a426af0c3d82609472e27825ef4ff8bf6">More...</a><br /></td></tr>
<tr class="separator:a426af0c3d82609472e27825ef4ff8bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7fc40b60438d1740772a6621c639a9"><td class="memTemplParams" colspan="2"><a id="afe7fc40b60438d1740772a6621c639a9"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:afe7fc40b60438d1740772a6621c639a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#afe7fc40b60438d1740772a6621c639a9">tssvd</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:afe7fc40b60438d1740772a6621c639a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:afe7fc40b60438d1740772a6621c639a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d99bd82cb072d5fb97515c3b1a0965"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af9d99bd82cb072d5fb97515c3b1a0965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af9d99bd82cb072d5fb97515c3b1a0965">cpsvd</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:af9d99bd82cb072d5fb97515c3b1a0965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable.  <a href="namespacelinalg.html#af9d99bd82cb072d5fb97515c3b1a0965">More...</a><br /></td></tr>
<tr class="separator:af9d99bd82cb072d5fb97515c3b1a0965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d98d9d9be9286de7cc5717473ade010"><td class="memTemplParams" colspan="2"><a id="a6d98d9d9be9286de7cc5717473ade010"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6d98d9d9be9286de7cc5717473ade010"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a6d98d9d9be9286de7cc5717473ade010">cpsvd</a> (const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a6d98d9d9be9286de7cc5717473ade010"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a6d98d9d9be9286de7cc5717473ade010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c9913039b136ddcc9b17f8e04be493"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a58c9913039b136ddcc9b17f8e04be493"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a58c9913039b136ddcc9b17f8e04be493">chol</a> (<a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a58c9913039b136ddcc9b17f8e04be493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Choleski factorization.  <a href="namespacelinalg.html#a58c9913039b136ddcc9b17f8e04be493">More...</a><br /></td></tr>
<tr class="separator:a58c9913039b136ddcc9b17f8e04be493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598dd44fc1f348c662311a5996e4fab"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4598dd44fc1f348c662311a5996e4fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a4598dd44fc1f348c662311a5996e4fab">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a4598dd44fc1f348c662311a5996e4fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#a4598dd44fc1f348c662311a5996e4fab">More...</a><br /></td></tr>
<tr class="separator:a4598dd44fc1f348c662311a5996e4fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e37f0ce00a99e19f69c0c790f21e684"><td class="memTemplParams" colspan="2"><a id="a7e37f0ce00a99e19f69c0c790f21e684"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a7e37f0ce00a99e19f69c0c790f21e684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a7e37f0ce00a99e19f69c0c790f21e684">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a7e37f0ce00a99e19f69c0c790f21e684"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a7e37f0ce00a99e19f69c0c790f21e684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faad9695d8ba603eb2fcf35b001f755"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2faad9695d8ba603eb2fcf35b001f755"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a2faad9695d8ba603eb2fcf35b001f755">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a2faad9695d8ba603eb2fcf35b001f755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#a2faad9695d8ba603eb2fcf35b001f755">More...</a><br /></td></tr>
<tr class="separator:a2faad9695d8ba603eb2fcf35b001f755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf89e8891a6a10497a65fc4a1daa201"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aadf89e8891a6a10497a65fc4a1daa201"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aadf89e8891a6a10497a65fc4a1daa201">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:aadf89e8891a6a10497a65fc4a1daa201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#aadf89e8891a6a10497a65fc4a1daa201">More...</a><br /></td></tr>
<tr class="separator:aadf89e8891a6a10497a65fc4a1daa201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92081bd5c471afb7ef30c78d894db97a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a92081bd5c471afb7ef30c78d894db97a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a92081bd5c471afb7ef30c78d894db97a">crossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a92081bd5c471afb7ef30c78d894db97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacelinalg.html#a92081bd5c471afb7ef30c78d894db97a">More...</a><br /></td></tr>
<tr class="separator:a92081bd5c471afb7ef30c78d894db97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae220218e85361fa2e2c06e9de9e61c"><td class="memTemplParams" colspan="2"><a id="adae220218e85361fa2e2c06e9de9e61c"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:adae220218e85361fa2e2c06e9de9e61c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#adae220218e85361fa2e2c06e9de9e61c">crossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:adae220218e85361fa2e2c06e9de9e61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:adae220218e85361fa2e2c06e9de9e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3c1fa0494b43c5cd2a83b52e1f7a06fc">tcrossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="namespacelinalg.html#a3c1fa0494b43c5cd2a83b52e1f7a06fc">More...</a><br /></td></tr>
<tr class="separator:a3c1fa0494b43c5cd2a83b52e1f7a06fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="memTemplParams" colspan="2"><a id="aa7a6eb25d0c22df7962c9f9305cf8c80"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa7a6eb25d0c22df7962c9f9305cf8c80">tcrossprod</a> (const REAL alpha, const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aa7a6eb25d0c22df7962c9f9305cf8c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ad6f65f84ac39f9d688a49dfb4bd5c1f7">xpose</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="namespacelinalg.html#ad6f65f84ac39f9d688a49dfb4bd5c1f7">More...</a><br /></td></tr>
<tr class="separator:ad6f65f84ac39f9d688a49dfb4bd5c1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03c48700965e927bd95cff4c1141840"><td class="memTemplParams" colspan="2"><a id="af03c48700965e927bd95cff4c1141840"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af03c48700965e927bd95cff4c1141840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af03c48700965e927bd95cff4c1141840">xpose</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:af03c48700965e927bd95cff4c1141840"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af03c48700965e927bd95cff4c1141840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12807dd969487fb835563c9998120beb"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a12807dd969487fb835563c9998120beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a12807dd969487fb835563c9998120beb">lu</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a12807dd969487fb835563c9998120beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="namespacelinalg.html#a12807dd969487fb835563c9998120beb">More...</a><br /></td></tr>
<tr class="separator:a12807dd969487fb835563c9998120beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f882607a9ba5e1b8d772b25fcead0d"><td class="memTemplParams" colspan="2"><a id="af4f882607a9ba5e1b8d772b25fcead0d"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af4f882607a9ba5e1b8d772b25fcead0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af4f882607a9ba5e1b8d772b25fcead0d">lu</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:af4f882607a9ba5e1b8d772b25fcead0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af4f882607a9ba5e1b8d772b25fcead0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb4770ac883a9a7fdc3051e96be728"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8ddb4770ac883a9a7fdc3051e96be728"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a8ddb4770ac883a9a7fdc3051e96be728">det</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="memdesc:a8ddb4770ac883a9a7fdc3051e96be728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant in logarithmic form.  <a href="namespacelinalg.html#a8ddb4770ac883a9a7fdc3051e96be728">More...</a><br /></td></tr>
<tr class="separator:a8ddb4770ac883a9a7fdc3051e96be728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e00c8ab31fc607ea4978ece08612f9"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a44e00c8ab31fc607ea4978ece08612f9"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a44e00c8ab31fc607ea4978ece08612f9">trace</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a44e00c8ab31fc607ea4978ece08612f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="namespacelinalg.html#a44e00c8ab31fc607ea4978ece08612f9">More...</a><br /></td></tr>
<tr class="separator:a44e00c8ab31fc607ea4978ece08612f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eac5c2d50bb27d713f3e435e1159def"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9eac5c2d50bb27d713f3e435e1159def"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9eac5c2d50bb27d713f3e435e1159def">svd</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a9eac5c2d50bb27d713f3e435e1159def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="namespacelinalg.html#a9eac5c2d50bb27d713f3e435e1159def">More...</a><br /></td></tr>
<tr class="separator:a9eac5c2d50bb27d713f3e435e1159def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af113b72e5d1d3c40fb732d4e22bb781a"><td class="memTemplParams" colspan="2"><a id="af113b72e5d1d3c40fb732d4e22bb781a"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af113b72e5d1d3c40fb732d4e22bb781a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af113b72e5d1d3c40fb732d4e22bb781a">svd</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:af113b72e5d1d3c40fb732d4e22bb781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af113b72e5d1d3c40fb732d4e22bb781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5e0babfee3b0f077701529f683b43"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a0ac5e0babfee3b0f077701529f683b43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a0ac5e0babfee3b0f077701529f683b43">eigen_sym</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a0ac5e0babfee3b0f077701529f683b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="namespacelinalg.html#a0ac5e0babfee3b0f077701529f683b43">More...</a><br /></td></tr>
<tr class="separator:a0ac5e0babfee3b0f077701529f683b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0860419eeabd495aabfd114f05e3227"><td class="memTemplParams" colspan="2"><a id="ac0860419eeabd495aabfd114f05e3227"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac0860419eeabd495aabfd114f05e3227"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ac0860419eeabd495aabfd114f05e3227">eigen_sym</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="memdesc:ac0860419eeabd495aabfd114f05e3227"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac0860419eeabd495aabfd114f05e3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb829c79675afc6746bbf2702332455"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9bb829c79675afc6746bbf2702332455"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9bb829c79675afc6746bbf2702332455">invert</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a9bb829c79675afc6746bbf2702332455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="namespacelinalg.html#a9bb829c79675afc6746bbf2702332455">More...</a><br /></td></tr>
<tr class="separator:a9bb829c79675afc6746bbf2702332455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f60d21486ed1a4ceeefa657d0123673"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5f60d21486ed1a4ceeefa657d0123673"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5f60d21486ed1a4ceeefa657d0123673">solve</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a5f60d21486ed1a4ceeefa657d0123673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="namespacelinalg.html#a5f60d21486ed1a4ceeefa657d0123673">More...</a><br /></td></tr>
<tr class="separator:a5f60d21486ed1a4ceeefa657d0123673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec10ae7fc07d5e5943efce2505103f3"><td class="memTemplParams" colspan="2"><a id="a5ec10ae7fc07d5e5943efce2505103f3"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5ec10ae7fc07d5e5943efce2505103f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5ec10ae7fc07d5e5943efce2505103f3">solve</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a5ec10ae7fc07d5e5943efce2505103f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a5ec10ae7fc07d5e5943efce2505103f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca26c3c4a5ea3c961243b001d7411faf"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aca26c3c4a5ea3c961243b001d7411faf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aca26c3c4a5ea3c961243b001d7411faf">qr</a> (const bool pivot, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;qraux)</td></tr>
<tr class="memdesc:aca26c3c4a5ea3c961243b001d7411faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR decomposition.  <a href="namespacelinalg.html#aca26c3c4a5ea3c961243b001d7411faf">More...</a><br /></td></tr>
<tr class="separator:aca26c3c4a5ea3c961243b001d7411faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c4d4d8ad61405beb76be756b5a7023"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a86c4d4d8ad61405beb76be756b5a7023"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a86c4d4d8ad61405beb76be756b5a7023">qr_Q</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;QR, const <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a86c4d4d8ad61405beb76be756b5a7023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a QR decomposition.  <a href="namespacelinalg.html#a86c4d4d8ad61405beb76be756b5a7023">More...</a><br /></td></tr>
<tr class="separator:a86c4d4d8ad61405beb76be756b5a7023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3253bb0cc0328bb8a68227d813f4059f"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3253bb0cc0328bb8a68227d813f4059f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3253bb0cc0328bb8a68227d813f4059f">qr_R</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;QR, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="memdesc:a3253bb0cc0328bb8a68227d813f4059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the R matrix from a QR decomposition.  <a href="namespacelinalg.html#a3253bb0cc0328bb8a68227d813f4059f">More...</a><br /></td></tr>
<tr class="separator:a3253bb0cc0328bb8a68227d813f4059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be4072e7f6b520f2a1885055a30b62a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2be4072e7f6b520f2a1885055a30b62a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a2be4072e7f6b520f2a1885055a30b62a">lq</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;lqaux)</td></tr>
<tr class="memdesc:a2be4072e7f6b520f2a1885055a30b62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LQ decomposition.  <a href="namespacelinalg.html#a2be4072e7f6b520f2a1885055a30b62a">More...</a><br /></td></tr>
<tr class="separator:a2be4072e7f6b520f2a1885055a30b62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6570f27edad224af0e0c6f3dac35d1"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:acb6570f27edad224af0e0c6f3dac35d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#acb6570f27edad224af0e0c6f3dac35d1">lq_L</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;LQ, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;L)</td></tr>
<tr class="memdesc:acb6570f27edad224af0e0c6f3dac35d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the L matrix from an LQ decomposition.  <a href="namespacelinalg.html#acb6570f27edad224af0e0c6f3dac35d1">More...</a><br /></td></tr>
<tr class="separator:acb6570f27edad224af0e0c6f3dac35d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c541a4a17548e1984bee9e5608bfe27"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5c541a4a17548e1984bee9e5608bfe27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a5c541a4a17548e1984bee9e5608bfe27">lq_Q</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;LQ, const <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;lqaux, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a5c541a4a17548e1984bee9e5608bfe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from an LQ decomposition.  <a href="namespacelinalg.html#a5c541a4a17548e1984bee9e5608bfe27">More...</a><br /></td></tr>
<tr class="separator:a5c541a4a17548e1984bee9e5608bfe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410768c0719347fd53d19727400bf54"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a7410768c0719347fd53d19727400bf54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a7410768c0719347fd53d19727400bf54">tssvd</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a7410768c0719347fd53d19727400bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition for tall/skinny data. The number of rows must be greater than the number of columns. If the number of rows is not significantly larger than the number of columns, this may not be more efficient than simply calling <code><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12" title="Computes the singular value decomposition.">linalg::svd()</a></code>.  <a href="namespacelinalg.html#a7410768c0719347fd53d19727400bf54">More...</a><br /></td></tr>
<tr class="separator:a7410768c0719347fd53d19727400bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c424819a01d57d9ec0a9f034bff4b4"><td class="memTemplParams" colspan="2"><a id="a53c424819a01d57d9ec0a9f034bff4b4"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a53c424819a01d57d9ec0a9f034bff4b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a53c424819a01d57d9ec0a9f034bff4b4">tssvd</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a53c424819a01d57d9ec0a9f034bff4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a53c424819a01d57d9ec0a9f034bff4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece15b308b495f8012691bdd0c090058"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aece15b308b495f8012691bdd0c090058"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aece15b308b495f8012691bdd0c090058">cpsvd</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:aece15b308b495f8012691bdd0c090058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable.  <a href="namespacelinalg.html#aece15b308b495f8012691bdd0c090058">More...</a><br /></td></tr>
<tr class="separator:aece15b308b495f8012691bdd0c090058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba502ba6be7b63ac5345984bdeeb9d2"><td class="memTemplParams" colspan="2"><a id="a6ba502ba6be7b63ac5345984bdeeb9d2"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6ba502ba6be7b63ac5345984bdeeb9d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a6ba502ba6be7b63ac5345984bdeeb9d2">cpsvd</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a6ba502ba6be7b63ac5345984bdeeb9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a6ba502ba6be7b63ac5345984bdeeb9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388a954f65cc342d08875554bc6b7a85"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a388a954f65cc342d08875554bc6b7a85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a388a954f65cc342d08875554bc6b7a85">chol</a> (<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a388a954f65cc342d08875554bc6b7a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Choleski factorization.  <a href="namespacelinalg.html#a388a954f65cc342d08875554bc6b7a85">More...</a><br /></td></tr>
<tr class="separator:a388a954f65cc342d08875554bc6b7a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715efcba095fd432b87ab6c1db54ea9d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a715efcba095fd432b87ab6c1db54ea9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a715efcba095fd432b87ab6c1db54ea9d">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a715efcba095fd432b87ab6c1db54ea9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#a715efcba095fd432b87ab6c1db54ea9d">More...</a><br /></td></tr>
<tr class="separator:a715efcba095fd432b87ab6c1db54ea9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="memTemplParams" colspan="2"><a id="a31fb7ea71170ac4c1d42d1dd88215bdb"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a31fb7ea71170ac4c1d42d1dd88215bdb">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a31fb7ea71170ac4c1d42d1dd88215bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa00d3b1a47a6b84fbd48defb75fe1545">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#aa00d3b1a47a6b84fbd48defb75fe1545">More...</a><br /></td></tr>
<tr class="separator:aa00d3b1a47a6b84fbd48defb75fe1545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667be52cee94da7dac6cf9b15c54eea4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a667be52cee94da7dac6cf9b15c54eea4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a667be52cee94da7dac6cf9b15c54eea4">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a667be52cee94da7dac6cf9b15c54eea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacelinalg.html#a667be52cee94da7dac6cf9b15c54eea4">More...</a><br /></td></tr>
<tr class="separator:a667be52cee94da7dac6cf9b15c54eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d8becf273135de34f2b20568e361"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af760d8becf273135de34f2b20568e361"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af760d8becf273135de34f2b20568e361">crossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:af760d8becf273135de34f2b20568e361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacelinalg.html#af760d8becf273135de34f2b20568e361">More...</a><br /></td></tr>
<tr class="separator:af760d8becf273135de34f2b20568e361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d706716a5be9e5a3931fbeff7816e"><td class="memTemplParams" colspan="2"><a id="a614d706716a5be9e5a3931fbeff7816e"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a614d706716a5be9e5a3931fbeff7816e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a614d706716a5be9e5a3931fbeff7816e">crossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a614d706716a5be9e5a3931fbeff7816e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a614d706716a5be9e5a3931fbeff7816e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e93959b15e348ce1cc0324955a7908b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3e93959b15e348ce1cc0324955a7908b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3e93959b15e348ce1cc0324955a7908b">tcrossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a3e93959b15e348ce1cc0324955a7908b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="namespacelinalg.html#a3e93959b15e348ce1cc0324955a7908b">More...</a><br /></td></tr>
<tr class="separator:a3e93959b15e348ce1cc0324955a7908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64867420c54679a013dc91e3c3b7c6c9"><td class="memTemplParams" colspan="2"><a id="a64867420c54679a013dc91e3c3b7c6c9"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a64867420c54679a013dc91e3c3b7c6c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a64867420c54679a013dc91e3c3b7c6c9">tcrossprod</a> (const REAL alpha, const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a64867420c54679a013dc91e3c3b7c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a64867420c54679a013dc91e3c3b7c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36f54cbabde4d6488c4dca65b87926"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1d36f54cbabde4d6488c4dca65b87926"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a1d36f54cbabde4d6488c4dca65b87926">xpose</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:a1d36f54cbabde4d6488c4dca65b87926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="namespacelinalg.html#a1d36f54cbabde4d6488c4dca65b87926">More...</a><br /></td></tr>
<tr class="separator:a1d36f54cbabde4d6488c4dca65b87926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d167ddd24b88513a250088dcaf428b"><td class="memTemplParams" colspan="2"><a id="a12d167ddd24b88513a250088dcaf428b"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a12d167ddd24b88513a250088dcaf428b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a12d167ddd24b88513a250088dcaf428b">xpose</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a12d167ddd24b88513a250088dcaf428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a12d167ddd24b88513a250088dcaf428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c1f61e19df98acdabc6fe26c8c03b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a640c1f61e19df98acdabc6fe26c8c03b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a640c1f61e19df98acdabc6fe26c8c03b">lu</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a640c1f61e19df98acdabc6fe26c8c03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="namespacelinalg.html#a640c1f61e19df98acdabc6fe26c8c03b">More...</a><br /></td></tr>
<tr class="separator:a640c1f61e19df98acdabc6fe26c8c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0a401d4326e44d985c750f367792df"><td class="memTemplParams" colspan="2"><a id="ace0a401d4326e44d985c750f367792df"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ace0a401d4326e44d985c750f367792df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ace0a401d4326e44d985c750f367792df">lu</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ace0a401d4326e44d985c750f367792df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ace0a401d4326e44d985c750f367792df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ff4dc2498d52a54a024cce46feacfe"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a65ff4dc2498d52a54a024cce46feacfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a65ff4dc2498d52a54a024cce46feacfe">det</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="memdesc:a65ff4dc2498d52a54a024cce46feacfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant in logarithmic form.  <a href="namespacelinalg.html#a65ff4dc2498d52a54a024cce46feacfe">More...</a><br /></td></tr>
<tr class="separator:a65ff4dc2498d52a54a024cce46feacfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00835947de924651a2dec07f98ff5d1b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a00835947de924651a2dec07f98ff5d1b"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a00835947de924651a2dec07f98ff5d1b">trace</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a00835947de924651a2dec07f98ff5d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="namespacelinalg.html#a00835947de924651a2dec07f98ff5d1b">More...</a><br /></td></tr>
<tr class="separator:a00835947de924651a2dec07f98ff5d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd6bce42acd5d23069863a6e7e623a4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:accd6bce42acd5d23069863a6e7e623a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#accd6bce42acd5d23069863a6e7e623a4">svd</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:accd6bce42acd5d23069863a6e7e623a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="namespacelinalg.html#accd6bce42acd5d23069863a6e7e623a4">More...</a><br /></td></tr>
<tr class="separator:accd6bce42acd5d23069863a6e7e623a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="memTemplParams" colspan="2"><a id="ab735b1be6cc7427db9c8c062e4e0ee51"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ab735b1be6cc7427db9c8c062e4e0ee51">svd</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab735b1be6cc7427db9c8c062e4e0ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e24c473ff21f6abef9af5c730b07fb2"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8e24c473ff21f6abef9af5c730b07fb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a8e24c473ff21f6abef9af5c730b07fb2">eigen_sym</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a8e24c473ff21f6abef9af5c730b07fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="namespacelinalg.html#a8e24c473ff21f6abef9af5c730b07fb2">More...</a><br /></td></tr>
<tr class="separator:a8e24c473ff21f6abef9af5c730b07fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8235a0717a937576fbb4d7e705214"><td class="memTemplParams" colspan="2"><a id="a10e8235a0717a937576fbb4d7e705214"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a10e8235a0717a937576fbb4d7e705214"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a10e8235a0717a937576fbb4d7e705214">eigen_sym</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="memdesc:a10e8235a0717a937576fbb4d7e705214"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a10e8235a0717a937576fbb4d7e705214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6444a6317f337b8b4bfc3ece04c836c1"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6444a6317f337b8b4bfc3ece04c836c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a6444a6317f337b8b4bfc3ece04c836c1">invert</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a6444a6317f337b8b4bfc3ece04c836c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="namespacelinalg.html#a6444a6317f337b8b4bfc3ece04c836c1">More...</a><br /></td></tr>
<tr class="separator:a6444a6317f337b8b4bfc3ece04c836c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94568ee6fe3627e1799e7d614d7cd6e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af94568ee6fe3627e1799e7d614d7cd6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#af94568ee6fe3627e1799e7d614d7cd6e">solve</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:af94568ee6fe3627e1799e7d614d7cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="namespacelinalg.html#af94568ee6fe3627e1799e7d614d7cd6e">More...</a><br /></td></tr>
<tr class="separator:af94568ee6fe3627e1799e7d614d7cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a622c0e17aeb39bb222e77c4cd184da"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a7a622c0e17aeb39bb222e77c4cd184da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a7a622c0e17aeb39bb222e77c4cd184da">qr</a> (const bool pivot, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux)</td></tr>
<tr class="memdesc:a7a622c0e17aeb39bb222e77c4cd184da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR decomposition.  <a href="namespacelinalg.html#a7a622c0e17aeb39bb222e77c4cd184da">More...</a><br /></td></tr>
<tr class="separator:a7a622c0e17aeb39bb222e77c4cd184da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd26c04fbd141c5e05c75868ed50868"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1cd26c04fbd141c5e05c75868ed50868"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a1cd26c04fbd141c5e05c75868ed50868">qr_Q</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;QR, const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a1cd26c04fbd141c5e05c75868ed50868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a QR decomposition.  <a href="namespacelinalg.html#a1cd26c04fbd141c5e05c75868ed50868">More...</a><br /></td></tr>
<tr class="separator:a1cd26c04fbd141c5e05c75868ed50868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613e2c41e4b24e137bde1f6e4899b335"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a613e2c41e4b24e137bde1f6e4899b335"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a613e2c41e4b24e137bde1f6e4899b335">qr_R</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;QR, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="memdesc:a613e2c41e4b24e137bde1f6e4899b335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the R matrix from a QR decomposition.  <a href="namespacelinalg.html#a613e2c41e4b24e137bde1f6e4899b335">More...</a><br /></td></tr>
<tr class="separator:a613e2c41e4b24e137bde1f6e4899b335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa863b301a49244b8b7b088ddae307ea8"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa863b301a49244b8b7b088ddae307ea8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa863b301a49244b8b7b088ddae307ea8">lq</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux)</td></tr>
<tr class="memdesc:aa863b301a49244b8b7b088ddae307ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LQ decomposition.  <a href="namespacelinalg.html#aa863b301a49244b8b7b088ddae307ea8">More...</a><br /></td></tr>
<tr class="separator:aa863b301a49244b8b7b088ddae307ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84fae45356c2d74a229dc51249ea3c6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa84fae45356c2d74a229dc51249ea3c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aa84fae45356c2d74a229dc51249ea3c6">lq_L</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;LQ, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;L)</td></tr>
<tr class="memdesc:aa84fae45356c2d74a229dc51249ea3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the L matrix from a LQ decomposition.  <a href="namespacelinalg.html#aa84fae45356c2d74a229dc51249ea3c6">More...</a><br /></td></tr>
<tr class="separator:aa84fae45356c2d74a229dc51249ea3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e92b5b233b29b9a0d99de2262decef3"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a7e92b5b233b29b9a0d99de2262decef3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a7e92b5b233b29b9a0d99de2262decef3">lq_Q</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;LQ, const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a7e92b5b233b29b9a0d99de2262decef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a LQ decomposition.  <a href="namespacelinalg.html#a7e92b5b233b29b9a0d99de2262decef3">More...</a><br /></td></tr>
<tr class="separator:a7e92b5b233b29b9a0d99de2262decef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aae2aff80064f6daf34b589d6b3703"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a77aae2aff80064f6daf34b589d6b3703"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a77aae2aff80064f6daf34b589d6b3703">tssvd</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a77aae2aff80064f6daf34b589d6b3703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition for tall/skinny data. The number of rows must be greater than the number of columns. If the number of rows is not significantly larger than the number of columns, this may not be more efficient than simply calling <code><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12" title="Computes the singular value decomposition.">linalg::svd()</a></code>.  <a href="namespacelinalg.html#a77aae2aff80064f6daf34b589d6b3703">More...</a><br /></td></tr>
<tr class="separator:a77aae2aff80064f6daf34b589d6b3703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b8a559aa9efcc4a956ff0792450c8c"><td class="memTemplParams" colspan="2"><a id="a94b8a559aa9efcc4a956ff0792450c8c"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a94b8a559aa9efcc4a956ff0792450c8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a94b8a559aa9efcc4a956ff0792450c8c">tssvd</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a94b8a559aa9efcc4a956ff0792450c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a94b8a559aa9efcc4a956ff0792450c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac41b37c6cda798113c35c179306e400"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aac41b37c6cda798113c35c179306e400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#aac41b37c6cda798113c35c179306e400">cpsvd</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:aac41b37c6cda798113c35c179306e400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable.  <a href="namespacelinalg.html#aac41b37c6cda798113c35c179306e400">More...</a><br /></td></tr>
<tr class="separator:aac41b37c6cda798113c35c179306e400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3538e45e3c084ace9328e7b5051d9b78"><td class="memTemplParams" colspan="2"><a id="a3538e45e3c084ace9328e7b5051d9b78"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3538e45e3c084ace9328e7b5051d9b78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a3538e45e3c084ace9328e7b5051d9b78">cpsvd</a> (const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a3538e45e3c084ace9328e7b5051d9b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a3538e45e3c084ace9328e7b5051d9b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c7dde69002943ce799926a7c73e55"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a187c7dde69002943ce799926a7c73e55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a187c7dde69002943ce799926a7c73e55">chol</a> (<a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a187c7dde69002943ce799926a7c73e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Choleski factorization.  <a href="namespacelinalg.html#a187c7dde69002943ce799926a7c73e55">More...</a><br /></td></tr>
<tr class="separator:a187c7dde69002943ce799926a7c73e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="memTemplParams" colspan="2"><a id="ac00eeb5ca75d6aa1110a7b64bd5d429f"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#ac00eeb5ca75d6aa1110a7b64bd5d429f">crossprod</a> (const REAL alpha, const <a class="el" href="classparmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x. <br /></td></tr>
<tr class="separator:ac00eeb5ca75d6aa1110a7b64bd5d429f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3c6302168d97b0d4d36caca4666b47"><td class="memTemplParams" colspan="2"><a id="a9a3c6302168d97b0d4d36caca4666b47"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9a3c6302168d97b0d4d36caca4666b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelinalg.html#a9a3c6302168d97b0d4d36caca4666b47">crossprod</a> (const REAL alpha, const <a class="el" href="classparmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a9a3c6302168d97b0d4d36caca4666b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a9a3c6302168d97b0d4d36caca4666b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e0960f9520a6c5af2198ec0eb710d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0960f9520a6c5af2198ec0eb710d23">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for the sum, the method will</dt><dd>throw a 'runtime_error' exception.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4598dd44fc1f348c662311a5996e4fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4598dd44fc1f348c662311a5996e4fab">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for the sum, the method will</dt><dd>throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuBLAS function cublasXgeam().</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715efcba095fd432b87ab6c1db54ea9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715efcba095fd432b87ab6c1db54ea9d">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for the sum, the method will</dt><dd>throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the PBLAS function pXgeadd().</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c9913039b136ddcc9b17f8e04be493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c9913039b136ddcc9b17f8e04be493">&#9670;&nbsp;</a></span>chol() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Choleski factorization. </p>
<p>The matrix should be 1. square, 2. symmetric, 3. positive-definite. Failure of any of these conditions can lead to a runtime exception. The input is replaced by its lower-triangular Choleski factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its lower-triangular Choleski factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xpotrf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n Some temporary work storage is needed.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a388a954f65cc342d08875554bc6b7a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388a954f65cc342d08875554bc6b7a85">&#9670;&nbsp;</a></span>chol() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Choleski factorization. </p>
<p>The matrix should be 1. square, 2. symmetric, 3. positive-definite. Failure of any of these conditions can lead to a runtime exception. The input is replaced by its lower-triangular Choleski factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its lower-triangular Choleski factor.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses the cuSOLVER function <code>cusolverDnXpotrf()</code>.</p>
<dl class="section user"><dt>Memory Allocations\n Some temporary work storage is needed.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187c7dde69002943ce799926a7c73e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187c7dde69002943ce799926a7c73e55">&#9670;&nbsp;</a></span>chol() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Choleski factorization. </p>
<p>The matrix should be 1. square, 2. symmetric, 3. positive-definite. Failure of any of these conditions can lead to a runtime exception. The input is replaced by its lower-triangular Choleski factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its lower-triangular Choleski factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXpotrf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n Some temporary work storage is needed.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9d99bd82cb072d5fb97515c3b1a0965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d99bd82cb072d5fb97515c3b1a0965">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X or X * X^T (whichever is smaller) and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses crossprod() or tcrossprod() (whichever is smaller), and</dt><dd><code><a class="el" href="namespacelinalg.html#a3659a4e16f32fda53611d7c9f1623e44" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">eigen_sym()</a></code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aece15b308b495f8012691bdd0c090058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece15b308b495f8012691bdd0c090058">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X or X * X^T (whichever is smaller) and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses crossprod() or tcrossprod() (whichever is smaller), and</dt><dd><code><a class="el" href="namespacelinalg.html#a3659a4e16f32fda53611d7c9f1623e44" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">eigen_sym()</a></code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac41b37c6cda798113c35c179306e400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac41b37c6cda798113c35c179306e400">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X or X * X^T (whichever is smaller) and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses crossprod() or tcrossprod() (whichever is smaller), and</dt><dd><code><a class="el" href="namespacelinalg.html#a3659a4e16f32fda53611d7c9f1623e44" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">eigen_sym()</a></code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be4ebb992a8574455962c8d894562dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be4ebb992a8574455962c8d894562dd">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the BLAS function Xsyrk().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92081bd5c471afb7ef30c78d894db97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92081bd5c471afb7ef30c78d894db97a">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuBLAS function cublasXsyrk().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af760d8becf273135de34f2b20568e361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760d8becf273135de34f2b20568e361">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the BLAS function pXsyrk().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63b1e768c0523aa04f8ef893b9205e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b1e768c0523aa04f8ef893b9205e44">&#9670;&nbsp;</a></span>det() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::det </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant in logarithmic form. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign</td><td>The sign of the determinant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modulus</td><td>Log of the modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses lu().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n Allocates temporary storage to compute the LU.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If an allocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ddb4770ac883a9a7fdc3051e96be728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddb4770ac883a9a7fdc3051e96be728">&#9670;&nbsp;</a></span>det() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::det </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant in logarithmic form. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign</td><td>The sign of the determinant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modulus</td><td>Log of the modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses lu().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n Allocates temporary storage to compute the LU.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If an allocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65ff4dc2498d52a54a024cce46feacfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ff4dc2498d52a54a024cce46feacfe">&#9670;&nbsp;</a></span>det() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::det </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant in logarithmic form. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign</td><td>The sign of the determinant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modulus</td><td>Log of the modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses lu().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n Allocates temporary storage to compute the LU.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If an allocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3659a4e16f32fda53611d7c9f1623e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3659a4e16f32fda53611d7c9f1623e44">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK functions Xsyevr().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If any output's dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square, a runtime_error exception is thrown.</dt><dd>If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ac5e0babfee3b0f077701529f683b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac5e0babfee3b0f077701529f683b43">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER functions cusolverDnXsyevd().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If any output's dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square, a runtime_error exception is thrown.</dt><dd>If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e24c473ff21f6abef9af5c730b07fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e24c473ff21f6abef9af5c730b07fb2">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK functions pXsyevr().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If any output's dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square, a runtime_error exception is thrown.</dt><dd>If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c2f7a9a68e276c55af4abdcd69f94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c2f7a9a68e276c55af4abdcd69f94f">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK functions Xgetrf() (LU) and Xgetri() (solve).</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n LU pivot data is allocated internally.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square, a runtime_error exception is thrown.</dt><dd>If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bb829c79675afc6746bbf2702332455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb829c79675afc6746bbf2702332455">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER functions cusolverDnXgetrf() (LU) and</dt><dd><code>cusolverDnXgetrs()</code> (solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations\n LU pivot data is allocated internally. The inverse is computed in</dt><dd>a copy before copying back to the input.</dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square, a runtime_error exception is thrown.</dt><dd>If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6444a6317f337b8b4bfc3ece04c836c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6444a6317f337b8b4bfc3ece04c836c1">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK functions pXgetrf() (LU) and pXgetri()</dt><dd>(solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations\n LU pivot data is allocated internally.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square, a runtime_error exception is thrown.</dt><dd>If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48fed51341966acce371a99cf7500d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fed51341966acce371a99cf7500d69">&#9670;&nbsp;</a></span>lq() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LQ decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact LQ representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xgelqf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be4072e7f6b520f2a1885055a30b62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be4072e7f6b520f2a1885055a30b62a">&#9670;&nbsp;</a></span>lq() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LQ decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact LQ representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n NOTE: not directly supported by cuSOLVER (vendor gpulapack + cuda</dt><dd>backend). In that case, the matrix is transposed and a QR is performed.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa863b301a49244b8b7b088ddae307ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa863b301a49244b8b7b088ddae307ea8">&#9670;&nbsp;</a></span>lq() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LQ decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact LQ representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXgelqf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc17ae91a41777545e424bf8d4cd8a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc17ae91a41777545e424bf8d4cd8a3c">&#9670;&nbsp;</a></span>lq_L() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq_L </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the L matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>The L matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xlacpy().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb6570f27edad224af0e0c6f3dac35d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6570f27edad224af0e0c6f3dac35d1">&#9670;&nbsp;</a></span>lq_L() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq_L </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the L matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>The L matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n NOTE: not directly supported by cuSOLVER (vendor gpulapack + cuda</dt><dd>backend). In that case, the matrix is transposed and a QR is performed.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa84fae45356c2d74a229dc51249ea3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84fae45356c2d74a229dc51249ea3c6">&#9670;&nbsp;</a></span>lq_L() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq_L </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the L matrix from a LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>The L matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXlacpy().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ad48f5ceb5b612451200befe82038a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ad48f5ceb5b612451200befe82038a">&#9670;&nbsp;</a></span>lq_Q() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xormlq().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c541a4a17548e1984bee9e5608bfe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c541a4a17548e1984bee9e5608bfe27">&#9670;&nbsp;</a></span>lq_Q() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n NOTE: not directly supported by cuSOLVER (vendor gpulapack + cuda</dt><dd>backend). In that case, the matrix is transposed and a QR is performed.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e92b5b233b29b9a0d99de2262decef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e92b5b233b29b9a0d99de2262decef3">&#9670;&nbsp;</a></span>lq_Q() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lq_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacelinalg.html#a48fed51341966acce371a99cf7500d69" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXormlq().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a936cd2444d3cc74c4623dedbbc9452ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936cd2444d3cc74c4623dedbbc9452ce">&#9670;&nbsp;</a></span>lu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xgetrf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the pivot vector is inappropriately sized, it will automatically</dt><dd>be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12807dd969487fb835563c9998120beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12807dd969487fb835563c9998120beb">&#9670;&nbsp;</a></span>lu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER function cusolverDnXgetrf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the pivot vector is inappropriately sized, it will automatically</dt><dd>be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a640c1f61e19df98acdabc6fe26c8c03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640c1f61e19df98acdabc6fe26c8c03b">&#9670;&nbsp;</a></span>lu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The ScaLAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXgetrf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the pivot vector is inappropriately sized, it will automatically</dt><dd>be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46be4663a5995ebc6438b880a2a2a36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46be4663a5995ebc6438b880a2a2a36c">&#9670;&nbsp;</a></span>matmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpumat.html">cpumat</a>&lt;REAL&gt; linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for a matrix product, the</dt><dd>method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the BLAS function Xgemm().</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42d2fe70ae468a1e56d83598d34d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42d2fe70ae468a1e56d83598d34d55c">&#9670;&nbsp;</a></span>matmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for a matrix product, the</dt><dd>method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the BLAS function Xgemm().</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2faad9695d8ba603eb2fcf35b001f755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faad9695d8ba603eb2fcf35b001f755">&#9670;&nbsp;</a></span>matmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt;REAL&gt; linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for a matrix product, the</dt><dd>method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuBLAS function cublasXgemm().</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadf89e8891a6a10497a65fc4a1daa201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf89e8891a6a10497a65fc4a1daa201">&#9670;&nbsp;</a></span>matmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for a matrix product, the</dt><dd>method will throw a 'runtime_error' exception.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuBLAS function cublasXgemm().</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa00d3b1a47a6b84fbd48defb75fe1545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00d3b1a47a6b84fbd48defb75fe1545">&#9670;&nbsp;</a></span>matmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpimat.html">mpimat</a>&lt;REAL&gt; linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for a matrix product, the</dt><dd>method will throw a 'runtime_error' exception. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the PBLAS function pXgemm().</dt><dd></dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a667be52cee94da7dac6cf9b15c54eea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667be52cee94da7dac6cf9b15c54eea4">&#9670;&nbsp;</a></span>matmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions\n If x and y are inappropriately sized for a matrix product, the</dt><dd>method will throw a 'runtime_error' exception. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown.</dd></dl>
<dl class="section user"><dt>Implementation Details\n Uses the PBLAS function pXgemm().</dt><dd></dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a24f47163185b7f9beca140de15228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a24f47163185b7f9beca140de15228">&#9670;&nbsp;</a></span>qr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact QR representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot</td><td>Should the factorization use column pivoting? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xgeqp3() if pivoting and Xgeqrf()</dt><dd>otherwise.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca26c3c4a5ea3c961243b001d7411faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca26c3c4a5ea3c961243b001d7411faf">&#9670;&nbsp;</a></span>qr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact QR representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot</td><td>NOTE Pivoting does not yet work on GPU. Should the factorization use column pivoting? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER function cusolverDnXgeqrf().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a622c0e17aeb39bb222e77c4cd184da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a622c0e17aeb39bb222e77c4cd184da">&#9670;&nbsp;</a></span>qr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact QR representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot</td><td>Should the factorization use column pivoting? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXgeqpf() if pivoting and pXgeqrf()</dt><dd>otherwise.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf79fca7662571560c744b4902edbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf79fca7662571560c744b4902edbff">&#9670;&nbsp;</a></span>qr_Q() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xormqr().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86c4d4d8ad61405beb76be756b5a7023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c4d4d8ad61405beb76be756b5a7023">&#9670;&nbsp;</a></span>qr_Q() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER function cusolverDnXormqr().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cd26c04fbd141c5e05c75868ed50868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd26c04fbd141c5e05c75868ed50868">&#9670;&nbsp;</a></span>qr_Q() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXormqr().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a103917c1951078e6d485018c8849d814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103917c1951078e6d485018c8849d814">&#9670;&nbsp;</a></span>qr_R() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr_R </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the R matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>The R matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xlacpy().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3253bb0cc0328bb8a68227d813f4059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3253bb0cc0328bb8a68227d813f4059f">&#9670;&nbsp;</a></span>qr_R() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr_R </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the R matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>The R matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses a custom LAPACK-like lacpy() clone.</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a613e2c41e4b24e137bde1f6e4899b335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613e2c41e4b24e137bde1f6e4899b335">&#9670;&nbsp;</a></span>qr_R() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::qr_R </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the R matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacelinalg.html#aa1a24f47163185b7f9beca140de15228" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>The R matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXlacpy().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ef3bf18806056a87fcd4df9fb013bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef3bf18806056a87fcd4df9fb013bd6">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK functions Xgesv().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n LU pivot data is allocated internally.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square or if the RHS is incompatible with the</dt><dd>LHS, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f60d21486ed1a4ceeefa657d0123673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f60d21486ed1a4ceeefa657d0123673">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its PLU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER functions cusolverDnXgetrf() (LU) and</dt><dd><code>cusolverDnXgetrs()</code> (solve).</dd></dl>
<dl class="section user"><dt>Memory Allocations\n LU pivot data is allocated internally.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square or if the RHS is incompatible with the</dt><dd>LHS, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af94568ee6fe3627e1799e7d614d7cd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94568ee6fe3627e1799e7d614d7cd6e">&#9670;&nbsp;</a></span>solve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK functions pXgesv().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n LU pivot data is allocated internally.</dt><dd></dd></dl>
<dl class="section user"><dt>Exceptions\n If the matrix is non-square or if the RHS is incompatible with the</dt><dd>LHS, a <code>runtime_error</code> exception is thrown. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff9f4d0b000f21e016aed2bd326e1a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9f4d0b000f21e016aed2bd326e1a12">&#9670;&nbsp;</a></span>svd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the LAPACK function Xgesvd().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eac5c2d50bb27d713f3e435e1159def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eac5c2d50bb27d713f3e435e1159def">&#9670;&nbsp;</a></span>svd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singnular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuSOLVER function cusolverDnXgesvd().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd6bce42acd5d23069863a6e7e623a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd6bce42acd5d23069863a6e7e623a4">&#9670;&nbsp;</a></span>svd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singnular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the ScaLAPACK function pXgesvd().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0bafc46faba643f53c56ca8d7d9f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bafc46faba643f53c56ca8d7d9f224">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the BLAS function Xsyrk().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c1fa0494b43c5cd2a83b52e1f7a06fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1fa0494b43c5cd2a83b52e1f7a06fc">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuBLAS function cublasXsyrk().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e93959b15e348ce1cc0324955a7908b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e93959b15e348ce1cc0324955a7908b">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the PBLAS function pXsyrk().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1203ef54c7f115eebe5ac9905931542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1203ef54c7f115eebe5ac9905931542">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44e00c8ab31fc607ea4978ece08612f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e00c8ab31fc607ea4978ece08612f9">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00835947de924651a2dec07f98ff5d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00835947de924651a2dec07f98ff5d1b">&#9670;&nbsp;</a></span>trace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426af0c3d82609472e27825ef4ff8bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426af0c3d82609472e27825ef4ff8bf6">&#9670;&nbsp;</a></span>tssvd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tssvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition for tall/skinny data. The number of rows must be greater than the number of columns. If the number of rows is not significantly larger than the number of columns, this may not be more efficient than simply calling <code><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12" title="Computes the singular value decomposition.">linalg::svd()</a></code>. </p>
<p>The operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses linalg::qr() and linalg::svd(), and if computing the</dt><dd>left/right singular vectors, <code><a class="el" href="namespacelinalg.html#a103917c1951078e6d485018c8849d814" title="Recover the R matrix from a QR decomposition.">linalg::qr_R()</a></code> and <code><a class="el" href="namespacelinalg.html#a9cf79fca7662571560c744b4902edbff" title="Recover the Q matrix from a QR decomposition.">linalg::qr_Q()</a></code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7410768c0719347fd53d19727400bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7410768c0719347fd53d19727400bf54">&#9670;&nbsp;</a></span>tssvd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tssvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition for tall/skinny data. The number of rows must be greater than the number of columns. If the number of rows is not significantly larger than the number of columns, this may not be more efficient than simply calling <code><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12" title="Computes the singular value decomposition.">linalg::svd()</a></code>. </p>
<p>The operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses linalg::qr() and linalg::svd(), and if computing the</dt><dd>left/right singular vectors, <code><a class="el" href="namespacelinalg.html#a103917c1951078e6d485018c8849d814" title="Recover the R matrix from a QR decomposition.">linalg::qr_R()</a></code> and <code><a class="el" href="namespacelinalg.html#a9cf79fca7662571560c744b4902edbff" title="Recover the Q matrix from a QR decomposition.">linalg::qr_Q()</a></code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77aae2aff80064f6daf34b589d6b3703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aae2aff80064f6daf34b589d6b3703">&#9670;&nbsp;</a></span>tssvd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::tssvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition for tall/skinny data. The number of rows must be greater than the number of columns. If the number of rows is not significantly larger than the number of columns, this may not be more efficient than simply calling <code><a class="el" href="namespacelinalg.html#aff9f4d0b000f21e016aed2bd326e1a12" title="Computes the singular value decomposition.">linalg::svd()</a></code>. </p>
<p>The operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses linalg::qr() and linalg::svd(), and if computing the</dt><dd>left/right singular vectors, <code><a class="el" href="namespacelinalg.html#a103917c1951078e6d485018c8849d814" title="Recover the R matrix from a QR decomposition.">linalg::qr_R()</a></code> and <code><a class="el" href="namespacelinalg.html#a9cf79fca7662571560c744b4902edbff" title="Recover the Q matrix from a QR decomposition.">linalg::qr_Q()</a></code>.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the any outputs are inappropriately sized, they will</dt><dd>automatically be re-allocated. Additionally, some temporary work storage is needed.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a (re-)allocation is triggered and fails, a bad_alloc</dt><dd>exception will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38aa5c66c35f4c9200646f86cbac9783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38aa5c66c35f4c9200646f86cbac9783">&#9670;&nbsp;</a></span>xpose() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f65f84ac39f9d688a49dfb4bd5c1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f65f84ac39f9d688a49dfb4bd5c1f7">&#9670;&nbsp;</a></span>xpose() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the cuBLAS function cublasXgeam().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d36f54cbabde4d6488c4dca65b87926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36f54cbabde4d6488c4dca65b87926">&#9670;&nbsp;</a></span>xpose() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation Details\n Uses the PBLAS function pXtran().</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n If the output dimension is inappropriately sized, it will</dt><dd>automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions\n If a reallocation is triggered and fails, a bad_alloc exception</dt><dd>will be thrown.</dd></dl>
<dl class="section user"><dt>Communication Details\n The method will communicate across all processes in the BLACS grid.</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelinalg.html">linalg</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
