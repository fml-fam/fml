<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fml: fml::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fml_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fml
   &#160;<span id="projectnumber">0.1-0</span>
   </div>
   <div id="projectbrief">Fused Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacefml_1_1linalg.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fml::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra functions.  
<a href="namespacefml_1_1linalg.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af31fc17f7e8fcb2d219c2c6071066089"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af31fc17f7e8fcb2d219c2c6071066089"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#af31fc17f7e8fcb2d219c2c6071066089">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:af31fc17f7e8fcb2d219c2c6071066089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#af31fc17f7e8fcb2d219c2c6071066089">More...</a><br /></td></tr>
<tr class="separator:af31fc17f7e8fcb2d219c2c6071066089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9957370bb61b0952dee6802a900b398"><td class="memTemplParams" colspan="2"><a id="ab9957370bb61b0952dee6802a900b398"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab9957370bb61b0952dee6802a900b398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab9957370bb61b0952dee6802a900b398">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ab9957370bb61b0952dee6802a900b398"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab9957370bb61b0952dee6802a900b398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781eb9009441462d4a1fbe6c5a9742ef"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a781eb9009441462d4a1fbe6c5a9742ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a781eb9009441462d4a1fbe6c5a9742ef">chol</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a781eb9009441462d4a1fbe6c5a9742ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Choleski factorization.  <a href="namespacefml_1_1linalg.html#a781eb9009441462d4a1fbe6c5a9742ef">More...</a><br /></td></tr>
<tr class="separator:a781eb9009441462d4a1fbe6c5a9742ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1932a6365c1b910d332ea2c036500ee4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1932a6365c1b910d332ea2c036500ee4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1932a6365c1b910d332ea2c036500ee4">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a1932a6365c1b910d332ea2c036500ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacefml_1_1linalg.html#a1932a6365c1b910d332ea2c036500ee4">More...</a><br /></td></tr>
<tr class="separator:a1932a6365c1b910d332ea2c036500ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62973bd2c1cc84a5af82d9ee69048866"><td class="memTemplParams" colspan="2"><a id="a62973bd2c1cc84a5af82d9ee69048866"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a62973bd2c1cc84a5af82d9ee69048866"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a62973bd2c1cc84a5af82d9ee69048866">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a62973bd2c1cc84a5af82d9ee69048866"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a62973bd2c1cc84a5af82d9ee69048866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d93a2c70ff9521879669e53d772c7d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a75d93a2c70ff9521879669e53d772c7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a75d93a2c70ff9521879669e53d772c7d">tcrossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a75d93a2c70ff9521879669e53d772c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="namespacefml_1_1linalg.html#a75d93a2c70ff9521879669e53d772c7d">More...</a><br /></td></tr>
<tr class="separator:a75d93a2c70ff9521879669e53d772c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7d6bda7e910da429b07a56ce486dfb"><td class="memTemplParams" colspan="2"><a id="a9a7d6bda7e910da429b07a56ce486dfb"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9a7d6bda7e910da429b07a56ce486dfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tcrossprod</b> (const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="separator:a9a7d6bda7e910da429b07a56ce486dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ecd011326b0b115562dd9dcf391fb"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3b7ecd011326b0b115562dd9dcf391fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3b7ecd011326b0b115562dd9dcf391fb">det</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="memdesc:a3b7ecd011326b0b115562dd9dcf391fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant in logarithmic form.  <a href="namespacefml_1_1linalg.html#a3b7ecd011326b0b115562dd9dcf391fb">More...</a><br /></td></tr>
<tr class="separator:a3b7ecd011326b0b115562dd9dcf391fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631534e78495dbdaf5dd94df17bedda3"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a631534e78495dbdaf5dd94df17bedda3"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a631534e78495dbdaf5dd94df17bedda3">dot</a> (const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a631534e78495dbdaf5dd94df17bedda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of two vectors, i.e. the sum of the product of the elements.  <a href="namespacefml_1_1linalg.html#a631534e78495dbdaf5dd94df17bedda3">More...</a><br /></td></tr>
<tr class="separator:a631534e78495dbdaf5dd94df17bedda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4827ed527e605589f495d64fcaf46dfb"><td class="memTemplParams" colspan="2"><a id="a4827ed527e605589f495d64fcaf46dfb"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4827ed527e605589f495d64fcaf46dfb"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a4827ed527e605589f495d64fcaf46dfb">dot</a> (const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a4827ed527e605589f495d64fcaf46dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a4827ed527e605589f495d64fcaf46dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6aba84a7e95dbdeb614b3f8f70cdce"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:afe6aba84a7e95dbdeb614b3f8f70cdce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce">eigen_sym</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:afe6aba84a7e95dbdeb614b3f8f70cdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce">More...</a><br /></td></tr>
<tr class="separator:afe6aba84a7e95dbdeb614b3f8f70cdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b34f8ca8f48f4ee32f1539f8876cfba"><td class="memTemplParams" colspan="2"><a id="a0b34f8ca8f48f4ee32f1539f8876cfba"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a0b34f8ca8f48f4ee32f1539f8876cfba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a0b34f8ca8f48f4ee32f1539f8876cfba">eigen_sym</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="memdesc:a0b34f8ca8f48f4ee32f1539f8876cfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a0b34f8ca8f48f4ee32f1539f8876cfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f00674f4d70ea3199fdcec3531e4397"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1f00674f4d70ea3199fdcec3531e4397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1f00674f4d70ea3199fdcec3531e4397">invert</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a1f00674f4d70ea3199fdcec3531e4397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="namespacefml_1_1linalg.html#a1f00674f4d70ea3199fdcec3531e4397">More...</a><br /></td></tr>
<tr class="separator:a1f00674f4d70ea3199fdcec3531e4397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273675041a86335869b1a06daab45d2a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a273675041a86335869b1a06daab45d2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a273675041a86335869b1a06daab45d2a">trinv</a> (const bool upper, const bool unit_diag, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a273675041a86335869b1a06daab45d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse of a triangular matrix.  <a href="namespacefml_1_1linalg.html#a273675041a86335869b1a06daab45d2a">More...</a><br /></td></tr>
<tr class="separator:a273675041a86335869b1a06daab45d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05637620851fd435dcf11d50a0fdc782"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a05637620851fd435dcf11d50a0fdc782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a05637620851fd435dcf11d50a0fdc782">lu</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a05637620851fd435dcf11d50a0fdc782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="namespacefml_1_1linalg.html#a05637620851fd435dcf11d50a0fdc782">More...</a><br /></td></tr>
<tr class="separator:a05637620851fd435dcf11d50a0fdc782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa127abd53f5cabaab0d46d26a05d1419"><td class="memTemplParams" colspan="2"><a id="aa127abd53f5cabaab0d46d26a05d1419"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa127abd53f5cabaab0d46d26a05d1419"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aa127abd53f5cabaab0d46d26a05d1419">lu</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aa127abd53f5cabaab0d46d26a05d1419"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aa127abd53f5cabaab0d46d26a05d1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550d8e6383cfa7f4e000d35c7f834bc4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a550d8e6383cfa7f4e000d35c7f834bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a550d8e6383cfa7f4e000d35c7f834bc4">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a550d8e6383cfa7f4e000d35c7f834bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#a550d8e6383cfa7f4e000d35c7f834bc4">More...</a><br /></td></tr>
<tr class="separator:a550d8e6383cfa7f4e000d35c7f834bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae950e30bfc9dfb4973c32e458777095d"><td class="memTemplParams" colspan="2"><a id="ae950e30bfc9dfb4973c32e458777095d"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae950e30bfc9dfb4973c32e458777095d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ae950e30bfc9dfb4973c32e458777095d">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ae950e30bfc9dfb4973c32e458777095d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae950e30bfc9dfb4973c32e458777095d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f72ec637465cf27fc865ffddd2c65f"><td class="memTemplParams" colspan="2"><a id="ac3f72ec637465cf27fc865ffddd2c65f"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac3f72ec637465cf27fc865ffddd2c65f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac3f72ec637465cf27fc865ffddd2c65f">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ac3f72ec637465cf27fc865ffddd2c65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac3f72ec637465cf27fc865ffddd2c65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e03200bc999283244412f62927c7b04"><td class="memTemplParams" colspan="2"><a id="a9e03200bc999283244412f62927c7b04"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9e03200bc999283244412f62927c7b04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a9e03200bc999283244412f62927c7b04">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a9e03200bc999283244412f62927c7b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a9e03200bc999283244412f62927c7b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef6e1211fd7fdf118709140e55ccbbc"><td class="memTemplParams" colspan="2"><a id="aeef6e1211fd7fdf118709140e55ccbbc"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aeef6e1211fd7fdf118709140e55ccbbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aeef6e1211fd7fdf118709140e55ccbbc">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:aeef6e1211fd7fdf118709140e55ccbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aeef6e1211fd7fdf118709140e55ccbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac345282da5df7c46e32843fbdfa7a1"><td class="memTemplParams" colspan="2"><a id="a0ac345282da5df7c46e32843fbdfa7a1"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a0ac345282da5df7c46e32843fbdfa7a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a0ac345282da5df7c46e32843fbdfa7a1">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a0ac345282da5df7c46e32843fbdfa7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a0ac345282da5df7c46e32843fbdfa7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153505fe39cf6c8d37acf40c179c3edf"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a153505fe39cf6c8d37acf40c179c3edf"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a153505fe39cf6c8d37acf40c179c3edf">norm_1</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a153505fe39cf6c8d37acf40c179c3edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 1 matrix norm, the maximum absolute column sum.  <a href="namespacefml_1_1linalg.html#a153505fe39cf6c8d37acf40c179c3edf">More...</a><br /></td></tr>
<tr class="separator:a153505fe39cf6c8d37acf40c179c3edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5718aa3b49c71f79bc99cbdfa23024f"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae5718aa3b49c71f79bc99cbdfa23024f"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ae5718aa3b49c71f79bc99cbdfa23024f">norm_I</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ae5718aa3b49c71f79bc99cbdfa23024f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity matrix norm, the maximum absolute row sum.  <a href="namespacefml_1_1linalg.html#ae5718aa3b49c71f79bc99cbdfa23024f">More...</a><br /></td></tr>
<tr class="separator:ae5718aa3b49c71f79bc99cbdfa23024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059b5a8032b13cf243ee1d4a45d61520"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a059b5a8032b13cf243ee1d4a45d61520"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a059b5a8032b13cf243ee1d4a45d61520">norm_F</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a059b5a8032b13cf243ee1d4a45d61520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius/Euclidean matrix norm.  <a href="namespacefml_1_1linalg.html#a059b5a8032b13cf243ee1d4a45d61520">More...</a><br /></td></tr>
<tr class="separator:a059b5a8032b13cf243ee1d4a45d61520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e31e7701f67c1be948f730347a6de"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a164e31e7701f67c1be948f730347a6de"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a164e31e7701f67c1be948f730347a6de">norm_M</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a164e31e7701f67c1be948f730347a6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum modulus matrix norm.  <a href="namespacefml_1_1linalg.html#a164e31e7701f67c1be948f730347a6de">More...</a><br /></td></tr>
<tr class="separator:a164e31e7701f67c1be948f730347a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1cc321073c3a24f287fcf27ee32e33"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6f1cc321073c3a24f287fcf27ee32e33"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a6f1cc321073c3a24f287fcf27ee32e33">norm_2</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a6f1cc321073c3a24f287fcf27ee32e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 2/spectral matrix norm.  <a href="namespacefml_1_1linalg.html#a6f1cc321073c3a24f287fcf27ee32e33">More...</a><br /></td></tr>
<tr class="separator:a6f1cc321073c3a24f287fcf27ee32e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cf5688ee5a622e134ab6d931224798"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a86cf5688ee5a622e134ab6d931224798"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a86cf5688ee5a622e134ab6d931224798">cond_1</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a86cf5688ee5a622e134ab6d931224798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the 1-norm.  <a href="namespacefml_1_1linalg.html#a86cf5688ee5a622e134ab6d931224798">More...</a><br /></td></tr>
<tr class="separator:a86cf5688ee5a622e134ab6d931224798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7387112b58428e080d403e2edb94e76b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a7387112b58428e080d403e2edb94e76b"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a7387112b58428e080d403e2edb94e76b">cond_I</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a7387112b58428e080d403e2edb94e76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the infinity norm.  <a href="namespacefml_1_1linalg.html#a7387112b58428e080d403e2edb94e76b">More...</a><br /></td></tr>
<tr class="separator:a7387112b58428e080d403e2edb94e76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3682f138b81b2e77122061fb87ac6192"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3682f138b81b2e77122061fb87ac6192"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3682f138b81b2e77122061fb87ac6192">cond_2</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a3682f138b81b2e77122061fb87ac6192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the 2 norm.  <a href="namespacefml_1_1linalg.html#a3682f138b81b2e77122061fb87ac6192">More...</a><br /></td></tr>
<tr class="separator:a3682f138b81b2e77122061fb87ac6192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f00a119a389317d318fdaab558c67d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a17f00a119a389317d318fdaab558c67d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d">qr</a> (const bool pivot, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux)</td></tr>
<tr class="memdesc:a17f00a119a389317d318fdaab558c67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR decomposition.  <a href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d">More...</a><br /></td></tr>
<tr class="separator:a17f00a119a389317d318fdaab558c67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41161525467b9696c1b1083e738f13ec"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a41161525467b9696c1b1083e738f13ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a41161525467b9696c1b1083e738f13ec">qr_Q</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;QR, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a41161525467b9696c1b1083e738f13ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a QR decomposition.  <a href="namespacefml_1_1linalg.html#a41161525467b9696c1b1083e738f13ec">More...</a><br /></td></tr>
<tr class="separator:a41161525467b9696c1b1083e738f13ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c66bb960a01eb48d2179dff06a8922"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a36c66bb960a01eb48d2179dff06a8922"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a36c66bb960a01eb48d2179dff06a8922">qr_R</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;QR, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="memdesc:a36c66bb960a01eb48d2179dff06a8922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the R matrix from a QR decomposition.  <a href="namespacefml_1_1linalg.html#a36c66bb960a01eb48d2179dff06a8922">More...</a><br /></td></tr>
<tr class="separator:a36c66bb960a01eb48d2179dff06a8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442c95b5a165469a61f5bc5822b016f2"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a442c95b5a165469a61f5bc5822b016f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2">lq</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux)</td></tr>
<tr class="memdesc:a442c95b5a165469a61f5bc5822b016f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LQ decomposition.  <a href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2">More...</a><br /></td></tr>
<tr class="separator:a442c95b5a165469a61f5bc5822b016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3fb47aba762c3ea659190d20fca5eb"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3b3fb47aba762c3ea659190d20fca5eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3b3fb47aba762c3ea659190d20fca5eb">lq_L</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;LQ, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;L)</td></tr>
<tr class="memdesc:a3b3fb47aba762c3ea659190d20fca5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the L matrix from an LQ decomposition.  <a href="namespacefml_1_1linalg.html#a3b3fb47aba762c3ea659190d20fca5eb">More...</a><br /></td></tr>
<tr class="separator:a3b3fb47aba762c3ea659190d20fca5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eacd684f4c6ea99d681007b610d659"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a91eacd684f4c6ea99d681007b610d659"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a91eacd684f4c6ea99d681007b610d659">lq_Q</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;LQ, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a91eacd684f4c6ea99d681007b610d659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from an LQ decomposition.  <a href="namespacefml_1_1linalg.html#a91eacd684f4c6ea99d681007b610d659">More...</a><br /></td></tr>
<tr class="separator:a91eacd684f4c6ea99d681007b610d659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35c383c81abcf4cc2231b5c3e11800e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af35c383c81abcf4cc2231b5c3e11800e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#af35c383c81abcf4cc2231b5c3e11800e">solve</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:af35c383c81abcf4cc2231b5c3e11800e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="namespacefml_1_1linalg.html#af35c383c81abcf4cc2231b5c3e11800e">More...</a><br /></td></tr>
<tr class="separator:af35c383c81abcf4cc2231b5c3e11800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210bedaddcb88460e24c27e4bbb4b51b"><td class="memTemplParams" colspan="2"><a id="a210bedaddcb88460e24c27e4bbb4b51b"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a210bedaddcb88460e24c27e4bbb4b51b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a210bedaddcb88460e24c27e4bbb4b51b">solve</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a210bedaddcb88460e24c27e4bbb4b51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a210bedaddcb88460e24c27e4bbb4b51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add583703d1c77a9f7236effb9b568f23"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:add583703d1c77a9f7236effb9b568f23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23">svd</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:add583703d1c77a9f7236effb9b568f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23">More...</a><br /></td></tr>
<tr class="separator:add583703d1c77a9f7236effb9b568f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666ce11853bf8dbec3651cf81f617a20"><td class="memTemplParams" colspan="2"><a id="a666ce11853bf8dbec3651cf81f617a20"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a666ce11853bf8dbec3651cf81f617a20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a666ce11853bf8dbec3651cf81f617a20">svd</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a666ce11853bf8dbec3651cf81f617a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a666ce11853bf8dbec3651cf81f617a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fce75514b99aca5b2789820191059f"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a75fce75514b99aca5b2789820191059f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a75fce75514b99aca5b2789820191059f">qrsvd</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a75fce75514b99aca5b2789820191059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization.  <a href="namespacefml_1_1linalg.html#a75fce75514b99aca5b2789820191059f">More...</a><br /></td></tr>
<tr class="separator:a75fce75514b99aca5b2789820191059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce52700a4915e0393ad27af6f898786"><td class="memTemplParams" colspan="2"><a id="adce52700a4915e0393ad27af6f898786"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:adce52700a4915e0393ad27af6f898786"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#adce52700a4915e0393ad27af6f898786">qrsvd</a> (<a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:adce52700a4915e0393ad27af6f898786"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:adce52700a4915e0393ad27af6f898786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ba317b627fa84ca085686faecf91e5"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a08ba317b627fa84ca085686faecf91e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a08ba317b627fa84ca085686faecf91e5">cpsvd</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a08ba317b627fa84ca085686faecf91e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable.  <a href="namespacefml_1_1linalg.html#a08ba317b627fa84ca085686faecf91e5">More...</a><br /></td></tr>
<tr class="separator:a08ba317b627fa84ca085686faecf91e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae812e759baa7ecd0575c64a50d3087dd"><td class="memTemplParams" colspan="2"><a id="ae812e759baa7ecd0575c64a50d3087dd"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae812e759baa7ecd0575c64a50d3087dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ae812e759baa7ecd0575c64a50d3087dd">cpsvd</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:ae812e759baa7ecd0575c64a50d3087dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae812e759baa7ecd0575c64a50d3087dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1da58b7dfd9cddfb4be7e2215b03a8"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:abc1da58b7dfd9cddfb4be7e2215b03a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#abc1da58b7dfd9cddfb4be7e2215b03a8">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:abc1da58b7dfd9cddfb4be7e2215b03a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation.  <a href="namespacefml_1_1linalg.html#abc1da58b7dfd9cddfb4be7e2215b03a8">More...</a><br /></td></tr>
<tr class="separator:abc1da58b7dfd9cddfb4be7e2215b03a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ec311d2af53535414d16b3f483dbbb"><td class="memTemplParams" colspan="2"><a id="a39ec311d2af53535414d16b3f483dbbb"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a39ec311d2af53535414d16b3f483dbbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a39ec311d2af53535414d16b3f483dbbb">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a39ec311d2af53535414d16b3f483dbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a39ec311d2af53535414d16b3f483dbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0456e9ec3c112ed3a0ca27cff164686"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af0456e9ec3c112ed3a0ca27cff164686"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#af0456e9ec3c112ed3a0ca27cff164686">trace</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:af0456e9ec3c112ed3a0ca27cff164686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="namespacefml_1_1linalg.html#af0456e9ec3c112ed3a0ca27cff164686">More...</a><br /></td></tr>
<tr class="separator:af0456e9ec3c112ed3a0ca27cff164686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1b30c504d3d9b0f52c44bce972fdf"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a75e1b30c504d3d9b0f52c44bce972fdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a75e1b30c504d3d9b0f52c44bce972fdf">xpose</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:a75e1b30c504d3d9b0f52c44bce972fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="namespacefml_1_1linalg.html#a75e1b30c504d3d9b0f52c44bce972fdf">More...</a><br /></td></tr>
<tr class="separator:a75e1b30c504d3d9b0f52c44bce972fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27969af13d0023f6f426cd887946f9e"><td class="memTemplParams" colspan="2"><a id="af27969af13d0023f6f426cd887946f9e"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af27969af13d0023f6f426cd887946f9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#af27969af13d0023f6f426cd887946f9e">xpose</a> (const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:af27969af13d0023f6f426cd887946f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af27969af13d0023f6f426cd887946f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a3f6e65195feca81a0b76024caf38"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa02a3f6e65195feca81a0b76024caf38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aa02a3f6e65195feca81a0b76024caf38">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:aa02a3f6e65195feca81a0b76024caf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#aa02a3f6e65195feca81a0b76024caf38">More...</a><br /></td></tr>
<tr class="separator:aa02a3f6e65195feca81a0b76024caf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87ad0a0eb3d91d82240b2c6e7ee7047"><td class="memTemplParams" colspan="2"><a id="ae87ad0a0eb3d91d82240b2c6e7ee7047"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae87ad0a0eb3d91d82240b2c6e7ee7047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ae87ad0a0eb3d91d82240b2c6e7ee7047">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ae87ad0a0eb3d91d82240b2c6e7ee7047"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae87ad0a0eb3d91d82240b2c6e7ee7047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975107e72bac0267373ea0b4a85941bf"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a975107e72bac0267373ea0b4a85941bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a975107e72bac0267373ea0b4a85941bf">chol</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a975107e72bac0267373ea0b4a85941bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Choleski factorization.  <a href="namespacefml_1_1linalg.html#a975107e72bac0267373ea0b4a85941bf">More...</a><br /></td></tr>
<tr class="separator:a975107e72bac0267373ea0b4a85941bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b1ddbdb20fe8e5b62eb104eb47e9c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a396b1ddbdb20fe8e5b62eb104eb47e9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a396b1ddbdb20fe8e5b62eb104eb47e9c">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a396b1ddbdb20fe8e5b62eb104eb47e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacefml_1_1linalg.html#a396b1ddbdb20fe8e5b62eb104eb47e9c">More...</a><br /></td></tr>
<tr class="separator:a396b1ddbdb20fe8e5b62eb104eb47e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b96114e7f71f280ab685978ce0ad181"><td class="memTemplParams" colspan="2"><a id="a8b96114e7f71f280ab685978ce0ad181"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8b96114e7f71f280ab685978ce0ad181"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a8b96114e7f71f280ab685978ce0ad181">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a8b96114e7f71f280ab685978ce0ad181"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a8b96114e7f71f280ab685978ce0ad181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b75d2e7c76340e7a32cd34d5e1b3087"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1b75d2e7c76340e7a32cd34d5e1b3087"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1b75d2e7c76340e7a32cd34d5e1b3087">tcrossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a1b75d2e7c76340e7a32cd34d5e1b3087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="namespacefml_1_1linalg.html#a1b75d2e7c76340e7a32cd34d5e1b3087">More...</a><br /></td></tr>
<tr class="separator:a1b75d2e7c76340e7a32cd34d5e1b3087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f0bf2ef1bc711fd78a81e9fb226fa1"><td class="memTemplParams" colspan="2"><a id="a29f0bf2ef1bc711fd78a81e9fb226fa1"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a29f0bf2ef1bc711fd78a81e9fb226fa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a29f0bf2ef1bc711fd78a81e9fb226fa1">tcrossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a29f0bf2ef1bc711fd78a81e9fb226fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a29f0bf2ef1bc711fd78a81e9fb226fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f79bc22832caf30b170e2f0796bca2"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a19f79bc22832caf30b170e2f0796bca2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a19f79bc22832caf30b170e2f0796bca2">det</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="memdesc:a19f79bc22832caf30b170e2f0796bca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant in logarithmic form.  <a href="namespacefml_1_1linalg.html#a19f79bc22832caf30b170e2f0796bca2">More...</a><br /></td></tr>
<tr class="separator:a19f79bc22832caf30b170e2f0796bca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11feb45b302a0bf02ef712899d4dafc3"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a11feb45b302a0bf02ef712899d4dafc3"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a11feb45b302a0bf02ef712899d4dafc3">dot</a> (const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a11feb45b302a0bf02ef712899d4dafc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of two vectors, i.e. the sum of the product of the elements.  <a href="namespacefml_1_1linalg.html#a11feb45b302a0bf02ef712899d4dafc3">More...</a><br /></td></tr>
<tr class="separator:a11feb45b302a0bf02ef712899d4dafc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713c0ee2d2c2e3faffd974e6bf52b9fa"><td class="memTemplParams" colspan="2"><a id="a713c0ee2d2c2e3faffd974e6bf52b9fa"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a713c0ee2d2c2e3faffd974e6bf52b9fa"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a713c0ee2d2c2e3faffd974e6bf52b9fa">dot</a> (const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a713c0ee2d2c2e3faffd974e6bf52b9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a713c0ee2d2c2e3faffd974e6bf52b9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c23508e3b9382368f83f4212595ce"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6b4c23508e3b9382368f83f4212595ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a6b4c23508e3b9382368f83f4212595ce">eigen_sym</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:a6b4c23508e3b9382368f83f4212595ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="namespacefml_1_1linalg.html#a6b4c23508e3b9382368f83f4212595ce">More...</a><br /></td></tr>
<tr class="separator:a6b4c23508e3b9382368f83f4212595ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a873832974d1fbf5a0bd1beb09f2f"><td class="memTemplParams" colspan="2"><a id="ac32a873832974d1fbf5a0bd1beb09f2f"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac32a873832974d1fbf5a0bd1beb09f2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac32a873832974d1fbf5a0bd1beb09f2f">eigen_sym</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="memdesc:ac32a873832974d1fbf5a0bd1beb09f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac32a873832974d1fbf5a0bd1beb09f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442ad9b632db67a7a25c25ad517af908"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a442ad9b632db67a7a25c25ad517af908"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a442ad9b632db67a7a25c25ad517af908">invert</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a442ad9b632db67a7a25c25ad517af908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="namespacefml_1_1linalg.html#a442ad9b632db67a7a25c25ad517af908">More...</a><br /></td></tr>
<tr class="separator:a442ad9b632db67a7a25c25ad517af908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4060a5a0de65bcd984c288ea4e77e5"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3d4060a5a0de65bcd984c288ea4e77e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3d4060a5a0de65bcd984c288ea4e77e5">trinv</a> (const bool upper, const bool unit_diag, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a3d4060a5a0de65bcd984c288ea4e77e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse of a triangular matrix.  <a href="namespacefml_1_1linalg.html#a3d4060a5a0de65bcd984c288ea4e77e5">More...</a><br /></td></tr>
<tr class="separator:a3d4060a5a0de65bcd984c288ea4e77e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e637b5cf435c79755089664d9aae1e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa8e637b5cf435c79755089664d9aae1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aa8e637b5cf435c79755089664d9aae1e">lu</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:aa8e637b5cf435c79755089664d9aae1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="namespacefml_1_1linalg.html#aa8e637b5cf435c79755089664d9aae1e">More...</a><br /></td></tr>
<tr class="separator:aa8e637b5cf435c79755089664d9aae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4a1d17d751e929b8dbcaeef780ce41"><td class="memTemplParams" colspan="2"><a id="afe4a1d17d751e929b8dbcaeef780ce41"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:afe4a1d17d751e929b8dbcaeef780ce41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#afe4a1d17d751e929b8dbcaeef780ce41">lu</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:afe4a1d17d751e929b8dbcaeef780ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:afe4a1d17d751e929b8dbcaeef780ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6460ba90776e3b8589448edc887791dd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a6460ba90776e3b8589448edc887791dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a6460ba90776e3b8589448edc887791dd">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a6460ba90776e3b8589448edc887791dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#a6460ba90776e3b8589448edc887791dd">More...</a><br /></td></tr>
<tr class="separator:a6460ba90776e3b8589448edc887791dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26082275b7e6b45c72bf7b154ae5a52"><td class="memTemplParams" colspan="2"><a id="ab26082275b7e6b45c72bf7b154ae5a52"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab26082275b7e6b45c72bf7b154ae5a52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab26082275b7e6b45c72bf7b154ae5a52">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ab26082275b7e6b45c72bf7b154ae5a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab26082275b7e6b45c72bf7b154ae5a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af571baaf61ef4820b6a176684fc98"><td class="memTemplParams" colspan="2"><a id="af6af571baaf61ef4820b6a176684fc98"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:af6af571baaf61ef4820b6a176684fc98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#af6af571baaf61ef4820b6a176684fc98">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:af6af571baaf61ef4820b6a176684fc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af6af571baaf61ef4820b6a176684fc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34300b4fe58eaa340e103a85566db5d5"><td class="memTemplParams" colspan="2"><a id="a34300b4fe58eaa340e103a85566db5d5"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a34300b4fe58eaa340e103a85566db5d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a34300b4fe58eaa340e103a85566db5d5">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a34300b4fe58eaa340e103a85566db5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a34300b4fe58eaa340e103a85566db5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0083bd8325ab34eb562d11c3ba2a19e0"><td class="memTemplParams" colspan="2"><a id="a0083bd8325ab34eb562d11c3ba2a19e0"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a0083bd8325ab34eb562d11c3ba2a19e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a0083bd8325ab34eb562d11c3ba2a19e0">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a0083bd8325ab34eb562d11c3ba2a19e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a0083bd8325ab34eb562d11c3ba2a19e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79138410941488929219202d3d2bdd6f"><td class="memTemplParams" colspan="2"><a id="a79138410941488929219202d3d2bdd6f"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a79138410941488929219202d3d2bdd6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a79138410941488929219202d3d2bdd6f">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a79138410941488929219202d3d2bdd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a79138410941488929219202d3d2bdd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f08a68f10da4b7f771ac48051877fcd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3f08a68f10da4b7f771ac48051877fcd"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3f08a68f10da4b7f771ac48051877fcd">norm_1</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a3f08a68f10da4b7f771ac48051877fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 1 matrix norm, the maximum absolute column sum.  <a href="namespacefml_1_1linalg.html#a3f08a68f10da4b7f771ac48051877fcd">More...</a><br /></td></tr>
<tr class="separator:a3f08a68f10da4b7f771ac48051877fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1482019ffd17d65a353e0f2d40074bd0"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1482019ffd17d65a353e0f2d40074bd0"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1482019ffd17d65a353e0f2d40074bd0">norm_I</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a1482019ffd17d65a353e0f2d40074bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity matrix norm, the maximum absolute row sum.  <a href="namespacefml_1_1linalg.html#a1482019ffd17d65a353e0f2d40074bd0">More...</a><br /></td></tr>
<tr class="separator:a1482019ffd17d65a353e0f2d40074bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f22ad24144c16f456991725554200a4"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3f22ad24144c16f456991725554200a4"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3f22ad24144c16f456991725554200a4">norm_F</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a3f22ad24144c16f456991725554200a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius/Euclidean matrix norm.  <a href="namespacefml_1_1linalg.html#a3f22ad24144c16f456991725554200a4">More...</a><br /></td></tr>
<tr class="separator:a3f22ad24144c16f456991725554200a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff467914d49d644b77c795e2f63219d9"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aff467914d49d644b77c795e2f63219d9"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aff467914d49d644b77c795e2f63219d9">norm_M</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aff467914d49d644b77c795e2f63219d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum modulus matrix norm.  <a href="namespacefml_1_1linalg.html#aff467914d49d644b77c795e2f63219d9">More...</a><br /></td></tr>
<tr class="separator:aff467914d49d644b77c795e2f63219d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d04f6add456b7f8103acca0029df4af"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3d04f6add456b7f8103acca0029df4af"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3d04f6add456b7f8103acca0029df4af">norm_2</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a3d04f6add456b7f8103acca0029df4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 2/spectral matrix norm.  <a href="namespacefml_1_1linalg.html#a3d04f6add456b7f8103acca0029df4af">More...</a><br /></td></tr>
<tr class="separator:a3d04f6add456b7f8103acca0029df4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f55b08f07cd12665eaf13d02178ca27"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9f55b08f07cd12665eaf13d02178ca27"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a9f55b08f07cd12665eaf13d02178ca27">cond_1</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a9f55b08f07cd12665eaf13d02178ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the 1-norm.  <a href="namespacefml_1_1linalg.html#a9f55b08f07cd12665eaf13d02178ca27">More...</a><br /></td></tr>
<tr class="separator:a9f55b08f07cd12665eaf13d02178ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0071ae9f6409026e92ba734112ba0285"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a0071ae9f6409026e92ba734112ba0285"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a0071ae9f6409026e92ba734112ba0285">cond_I</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a0071ae9f6409026e92ba734112ba0285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the infinity norm.  <a href="namespacefml_1_1linalg.html#a0071ae9f6409026e92ba734112ba0285">More...</a><br /></td></tr>
<tr class="separator:a0071ae9f6409026e92ba734112ba0285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02363e50589c4f8256500b83dbd2797"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ad02363e50589c4f8256500b83dbd2797"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ad02363e50589c4f8256500b83dbd2797">cond_2</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ad02363e50589c4f8256500b83dbd2797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the 2 norm.  <a href="namespacefml_1_1linalg.html#ad02363e50589c4f8256500b83dbd2797">More...</a><br /></td></tr>
<tr class="separator:ad02363e50589c4f8256500b83dbd2797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f327d0a2bf45c9bf61f1cafa34fccd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a32f327d0a2bf45c9bf61f1cafa34fccd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a32f327d0a2bf45c9bf61f1cafa34fccd">qr</a> (const bool pivot, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;qraux)</td></tr>
<tr class="memdesc:a32f327d0a2bf45c9bf61f1cafa34fccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR decomposition.  <a href="namespacefml_1_1linalg.html#a32f327d0a2bf45c9bf61f1cafa34fccd">More...</a><br /></td></tr>
<tr class="separator:a32f327d0a2bf45c9bf61f1cafa34fccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1fb6ea4956410f9673d87d8435cfa"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2bd1fb6ea4956410f9673d87d8435cfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a2bd1fb6ea4956410f9673d87d8435cfa">qr_Q</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;QR, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a2bd1fb6ea4956410f9673d87d8435cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a QR decomposition.  <a href="namespacefml_1_1linalg.html#a2bd1fb6ea4956410f9673d87d8435cfa">More...</a><br /></td></tr>
<tr class="separator:a2bd1fb6ea4956410f9673d87d8435cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b146af4d02d8fd2d633af125081b8dc"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2b146af4d02d8fd2d633af125081b8dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a2b146af4d02d8fd2d633af125081b8dc">qr_R</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;QR, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="memdesc:a2b146af4d02d8fd2d633af125081b8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the R matrix from a QR decomposition.  <a href="namespacefml_1_1linalg.html#a2b146af4d02d8fd2d633af125081b8dc">More...</a><br /></td></tr>
<tr class="separator:a2b146af4d02d8fd2d633af125081b8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312232cff8743c9075762eb228d3edf7"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a312232cff8743c9075762eb228d3edf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a312232cff8743c9075762eb228d3edf7">lq</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;lqaux)</td></tr>
<tr class="memdesc:a312232cff8743c9075762eb228d3edf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LQ decomposition.  <a href="namespacefml_1_1linalg.html#a312232cff8743c9075762eb228d3edf7">More...</a><br /></td></tr>
<tr class="separator:a312232cff8743c9075762eb228d3edf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58babcaf925f2998df1ebbcbaaa680c0"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a58babcaf925f2998df1ebbcbaaa680c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a58babcaf925f2998df1ebbcbaaa680c0">lq_L</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;LQ, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;L)</td></tr>
<tr class="memdesc:a58babcaf925f2998df1ebbcbaaa680c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the L matrix from an LQ decomposition.  <a href="namespacefml_1_1linalg.html#a58babcaf925f2998df1ebbcbaaa680c0">More...</a><br /></td></tr>
<tr class="separator:a58babcaf925f2998df1ebbcbaaa680c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4898b487932411e56ac94d42bfd81647"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4898b487932411e56ac94d42bfd81647"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a4898b487932411e56ac94d42bfd81647">lq_Q</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;LQ, const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;lqaux, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a4898b487932411e56ac94d42bfd81647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from an LQ decomposition.  <a href="namespacefml_1_1linalg.html#a4898b487932411e56ac94d42bfd81647">More...</a><br /></td></tr>
<tr class="separator:a4898b487932411e56ac94d42bfd81647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50bf59ecc984eb120ef98a5eaf35a99"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab50bf59ecc984eb120ef98a5eaf35a99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab50bf59ecc984eb120ef98a5eaf35a99">solve</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ab50bf59ecc984eb120ef98a5eaf35a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="namespacefml_1_1linalg.html#ab50bf59ecc984eb120ef98a5eaf35a99">More...</a><br /></td></tr>
<tr class="separator:ab50bf59ecc984eb120ef98a5eaf35a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad498a3f15cfcca4dacd56595364233bd"><td class="memTemplParams" colspan="2"><a id="ad498a3f15cfcca4dacd56595364233bd"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ad498a3f15cfcca4dacd56595364233bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ad498a3f15cfcca4dacd56595364233bd">solve</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ad498a3f15cfcca4dacd56595364233bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ad498a3f15cfcca4dacd56595364233bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9475ced0bd576bfb9c05d7c0fffe0c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:add9475ced0bd576bfb9c05d7c0fffe0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#add9475ced0bd576bfb9c05d7c0fffe0c">svd</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:add9475ced0bd576bfb9c05d7c0fffe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition.  <a href="namespacefml_1_1linalg.html#add9475ced0bd576bfb9c05d7c0fffe0c">More...</a><br /></td></tr>
<tr class="separator:add9475ced0bd576bfb9c05d7c0fffe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c6a9c556ecb76b676e14a04b9ffd4"><td class="memTemplParams" colspan="2"><a id="ad39c6a9c556ecb76b676e14a04b9ffd4"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ad39c6a9c556ecb76b676e14a04b9ffd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ad39c6a9c556ecb76b676e14a04b9ffd4">svd</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:ad39c6a9c556ecb76b676e14a04b9ffd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ad39c6a9c556ecb76b676e14a04b9ffd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d551221bfb1be0037c55d1c4645da6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aa1d551221bfb1be0037c55d1c4645da6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aa1d551221bfb1be0037c55d1c4645da6">qrsvd</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:aa1d551221bfb1be0037c55d1c4645da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization.  <a href="namespacefml_1_1linalg.html#aa1d551221bfb1be0037c55d1c4645da6">More...</a><br /></td></tr>
<tr class="separator:aa1d551221bfb1be0037c55d1c4645da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9063c7538f30aa5147ddc41c1883b97a"><td class="memTemplParams" colspan="2"><a id="a9063c7538f30aa5147ddc41c1883b97a"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9063c7538f30aa5147ddc41c1883b97a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a9063c7538f30aa5147ddc41c1883b97a">qrsvd</a> (<a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a9063c7538f30aa5147ddc41c1883b97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a9063c7538f30aa5147ddc41c1883b97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17472ad16a3a5b46bb5fa67b1b3c58a6"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a17472ad16a3a5b46bb5fa67b1b3c58a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a17472ad16a3a5b46bb5fa67b1b3c58a6">cpsvd</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a17472ad16a3a5b46bb5fa67b1b3c58a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable.  <a href="namespacefml_1_1linalg.html#a17472ad16a3a5b46bb5fa67b1b3c58a6">More...</a><br /></td></tr>
<tr class="separator:a17472ad16a3a5b46bb5fa67b1b3c58a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a5cd8b2709ade3c2d90fd9b4dc1eb"><td class="memTemplParams" colspan="2"><a id="a1a0a5cd8b2709ade3c2d90fd9b4dc1eb"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1a0a5cd8b2709ade3c2d90fd9b4dc1eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1a0a5cd8b2709ade3c2d90fd9b4dc1eb">cpsvd</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a1a0a5cd8b2709ade3c2d90fd9b4dc1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a1a0a5cd8b2709ade3c2d90fd9b4dc1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5808d941b1f4802a629b3d4da0620804"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5808d941b1f4802a629b3d4da0620804"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a5808d941b1f4802a629b3d4da0620804">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a5808d941b1f4802a629b3d4da0620804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation.  <a href="namespacefml_1_1linalg.html#a5808d941b1f4802a629b3d4da0620804">More...</a><br /></td></tr>
<tr class="separator:a5808d941b1f4802a629b3d4da0620804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b577ec86b2caf811c0f900755a6938"><td class="memTemplParams" colspan="2"><a id="a30b577ec86b2caf811c0f900755a6938"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a30b577ec86b2caf811c0f900755a6938"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a30b577ec86b2caf811c0f900755a6938">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a30b577ec86b2caf811c0f900755a6938"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a30b577ec86b2caf811c0f900755a6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239113c5267ec96f309b345366816f5c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a239113c5267ec96f309b345366816f5c"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a239113c5267ec96f309b345366816f5c">trace</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a239113c5267ec96f309b345366816f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="namespacefml_1_1linalg.html#a239113c5267ec96f309b345366816f5c">More...</a><br /></td></tr>
<tr class="separator:a239113c5267ec96f309b345366816f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fb08fbc91d1ef95535349b764040ff"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab2fb08fbc91d1ef95535349b764040ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab2fb08fbc91d1ef95535349b764040ff">xpose</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:ab2fb08fbc91d1ef95535349b764040ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="namespacefml_1_1linalg.html#ab2fb08fbc91d1ef95535349b764040ff">More...</a><br /></td></tr>
<tr class="separator:ab2fb08fbc91d1ef95535349b764040ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb832a2776a9333fe28e6dc2a227f755"><td class="memTemplParams" colspan="2"><a id="abb832a2776a9333fe28e6dc2a227f755"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:abb832a2776a9333fe28e6dc2a227f755"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#abb832a2776a9333fe28e6dc2a227f755">xpose</a> (const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:abb832a2776a9333fe28e6dc2a227f755"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:abb832a2776a9333fe28e6dc2a227f755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac3b2bfdd57e2f1aa167cc21260741f"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a9ac3b2bfdd57e2f1aa167cc21260741f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a9ac3b2bfdd57e2f1aa167cc21260741f">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a9ac3b2bfdd57e2f1aa167cc21260741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#a9ac3b2bfdd57e2f1aa167cc21260741f">More...</a><br /></td></tr>
<tr class="separator:a9ac3b2bfdd57e2f1aa167cc21260741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef7f955518464357f02c4563adedb39"><td class="memTemplParams" colspan="2"><a id="adef7f955518464357f02c4563adedb39"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:adef7f955518464357f02c4563adedb39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#adef7f955518464357f02c4563adedb39">add</a> (const bool transx, const bool transy, const REAL alpha, const REAL beta, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:adef7f955518464357f02c4563adedb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:adef7f955518464357f02c4563adedb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c9aac32d61af8902f7e9e842aba1e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab55c9aac32d61af8902f7e9e842aba1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab55c9aac32d61af8902f7e9e842aba1e">chol</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ab55c9aac32d61af8902f7e9e842aba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Choleski factorization.  <a href="namespacefml_1_1linalg.html#ab55c9aac32d61af8902f7e9e842aba1e">More...</a><br /></td></tr>
<tr class="separator:ab55c9aac32d61af8902f7e9e842aba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f1f1a03b2ca66ae42893e51bd69d65"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a11f1f1a03b2ca66ae42893e51bd69d65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a11f1f1a03b2ca66ae42893e51bd69d65">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a11f1f1a03b2ca66ae42893e51bd69d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacefml_1_1linalg.html#a11f1f1a03b2ca66ae42893e51bd69d65">More...</a><br /></td></tr>
<tr class="separator:a11f1f1a03b2ca66ae42893e51bd69d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf8d7d887ce83e83348d59141c6bb26"><td class="memTemplParams" colspan="2"><a id="a8cf8d7d887ce83e83348d59141c6bb26"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a8cf8d7d887ce83e83348d59141c6bb26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a8cf8d7d887ce83e83348d59141c6bb26">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a8cf8d7d887ce83e83348d59141c6bb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a8cf8d7d887ce83e83348d59141c6bb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167161d3b790e902ef894e8764913c65"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a167161d3b790e902ef894e8764913c65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a167161d3b790e902ef894e8764913c65">tcrossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a167161d3b790e902ef894e8764913c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x*x^T.  <a href="namespacefml_1_1linalg.html#a167161d3b790e902ef894e8764913c65">More...</a><br /></td></tr>
<tr class="separator:a167161d3b790e902ef894e8764913c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ea57c87dc555fec39191be8e5cab2b"><td class="memTemplParams" colspan="2"><a id="a44ea57c87dc555fec39191be8e5cab2b"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a44ea57c87dc555fec39191be8e5cab2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a44ea57c87dc555fec39191be8e5cab2b">tcrossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a44ea57c87dc555fec39191be8e5cab2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a44ea57c87dc555fec39191be8e5cab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d87be93e642f5f4b5d2176fb855bf32"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a3d87be93e642f5f4b5d2176fb855bf32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a3d87be93e642f5f4b5d2176fb855bf32">det</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, int &amp;sign, REAL &amp;modulus)</td></tr>
<tr class="memdesc:a3d87be93e642f5f4b5d2176fb855bf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant in logarithmic form.  <a href="namespacefml_1_1linalg.html#a3d87be93e642f5f4b5d2176fb855bf32">More...</a><br /></td></tr>
<tr class="separator:a3d87be93e642f5f4b5d2176fb855bf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab11d2ad0dc980fa3feb70ca118b6165"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aab11d2ad0dc980fa3feb70ca118b6165"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aab11d2ad0dc980fa3feb70ca118b6165">eigen_sym</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values)</td></tr>
<tr class="memdesc:aab11d2ad0dc980fa3feb70ca118b6165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.  <a href="namespacefml_1_1linalg.html#aab11d2ad0dc980fa3feb70ca118b6165">More...</a><br /></td></tr>
<tr class="separator:aab11d2ad0dc980fa3feb70ca118b6165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f4d359fbca14d9f9c08bcd13912162"><td class="memTemplParams" colspan="2"><a id="a87f4d359fbca14d9f9c08bcd13912162"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a87f4d359fbca14d9f9c08bcd13912162"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a87f4d359fbca14d9f9c08bcd13912162">eigen_sym</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;values, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;vectors)</td></tr>
<tr class="memdesc:a87f4d359fbca14d9f9c08bcd13912162"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a87f4d359fbca14d9f9c08bcd13912162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedd514e600cdd1a66ff400a6493d72e"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:adedd514e600cdd1a66ff400a6493d72e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#adedd514e600cdd1a66ff400a6493d72e">invert</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:adedd514e600cdd1a66ff400a6493d72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse.  <a href="namespacefml_1_1linalg.html#adedd514e600cdd1a66ff400a6493d72e">More...</a><br /></td></tr>
<tr class="separator:adedd514e600cdd1a66ff400a6493d72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e370a6c1e4ba7935114a9efb3323b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aaf8e370a6c1e4ba7935114a9efb3323b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aaf8e370a6c1e4ba7935114a9efb3323b">trinv</a> (const bool upper, const bool unit_diag, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:aaf8e370a6c1e4ba7935114a9efb3323b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix inverse of a triangular matrix.  <a href="namespacefml_1_1linalg.html#aaf8e370a6c1e4ba7935114a9efb3323b">More...</a><br /></td></tr>
<tr class="separator:aaf8e370a6c1e4ba7935114a9efb3323b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19473e478ddbca6b04ba74e4ab0e437b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a19473e478ddbca6b04ba74e4ab0e437b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a19473e478ddbca6b04ba74e4ab0e437b">lu</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; int &gt; &amp;p, int &amp;info)</td></tr>
<tr class="memdesc:a19473e478ddbca6b04ba74e4ab0e437b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU factorization with partial pivoting.  <a href="namespacefml_1_1linalg.html#a19473e478ddbca6b04ba74e4ab0e437b">More...</a><br /></td></tr>
<tr class="separator:a19473e478ddbca6b04ba74e4ab0e437b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4de4002dbb8449116083e1d2cba2a"><td class="memTemplParams" colspan="2"><a id="a56c4de4002dbb8449116083e1d2cba2a"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a56c4de4002dbb8449116083e1d2cba2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a56c4de4002dbb8449116083e1d2cba2a">lu</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a56c4de4002dbb8449116083e1d2cba2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a56c4de4002dbb8449116083e1d2cba2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218a6b09807150aaf820e95049124ce3"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a218a6b09807150aaf820e95049124ce3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a218a6b09807150aaf820e95049124ce3">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a218a6b09807150aaf820e95049124ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#a218a6b09807150aaf820e95049124ce3">More...</a><br /></td></tr>
<tr class="separator:a218a6b09807150aaf820e95049124ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add560d8d285bd77f22108a8f08fb8aa0"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:add560d8d285bd77f22108a8f08fb8aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#add560d8d285bd77f22108a8f08fb8aa0">matmult</a> (const bool transx, const bool transy, const REAL alpha, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:add560d8d285bd77f22108a8f08fb8aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T.  <a href="namespacefml_1_1linalg.html#add560d8d285bd77f22108a8f08fb8aa0">More...</a><br /></td></tr>
<tr class="separator:add560d8d285bd77f22108a8f08fb8aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a8bc4594a3ac1bcfd74bcf3b4c9b3d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a37a8bc4594a3ac1bcfd74bcf3b4c9b3d"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a37a8bc4594a3ac1bcfd74bcf3b4c9b3d">norm_1</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a37a8bc4594a3ac1bcfd74bcf3b4c9b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 1 matrix norm, the maximum absolute column sum.  <a href="namespacefml_1_1linalg.html#a37a8bc4594a3ac1bcfd74bcf3b4c9b3d">More...</a><br /></td></tr>
<tr class="separator:a37a8bc4594a3ac1bcfd74bcf3b4c9b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a5dcdfd1aebe704f96550b0bb1b126"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a35a5dcdfd1aebe704f96550b0bb1b126"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a35a5dcdfd1aebe704f96550b0bb1b126">norm_I</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a35a5dcdfd1aebe704f96550b0bb1b126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity matrix norm, the maximum absolute row sum.  <a href="namespacefml_1_1linalg.html#a35a5dcdfd1aebe704f96550b0bb1b126">More...</a><br /></td></tr>
<tr class="separator:a35a5dcdfd1aebe704f96550b0bb1b126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112c5c64cea35eaed6a4d3af39aebb29"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a112c5c64cea35eaed6a4d3af39aebb29"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a112c5c64cea35eaed6a4d3af39aebb29">norm_F</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a112c5c64cea35eaed6a4d3af39aebb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius/Euclidean matrix norm.  <a href="namespacefml_1_1linalg.html#a112c5c64cea35eaed6a4d3af39aebb29">More...</a><br /></td></tr>
<tr class="separator:a112c5c64cea35eaed6a4d3af39aebb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac562dabd4ca5decaa33b72f16b254624"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac562dabd4ca5decaa33b72f16b254624"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac562dabd4ca5decaa33b72f16b254624">norm_M</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ac562dabd4ca5decaa33b72f16b254624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum modulus matrix norm.  <a href="namespacefml_1_1linalg.html#ac562dabd4ca5decaa33b72f16b254624">More...</a><br /></td></tr>
<tr class="separator:ac562dabd4ca5decaa33b72f16b254624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263c1fe506add0870e09c033c5ebabc3"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a263c1fe506add0870e09c033c5ebabc3"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a263c1fe506add0870e09c033c5ebabc3">norm_2</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a263c1fe506add0870e09c033c5ebabc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 2/spectral matrix norm.  <a href="namespacefml_1_1linalg.html#a263c1fe506add0870e09c033c5ebabc3">More...</a><br /></td></tr>
<tr class="separator:a263c1fe506add0870e09c033c5ebabc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d99edb5e8bc0f6374e67a201611961"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a17d99edb5e8bc0f6374e67a201611961"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a17d99edb5e8bc0f6374e67a201611961">cond_1</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a17d99edb5e8bc0f6374e67a201611961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the 1-norm.  <a href="namespacefml_1_1linalg.html#a17d99edb5e8bc0f6374e67a201611961">More...</a><br /></td></tr>
<tr class="separator:a17d99edb5e8bc0f6374e67a201611961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183dd17d44d42e3d488e827b60449d98"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a183dd17d44d42e3d488e827b60449d98"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a183dd17d44d42e3d488e827b60449d98">cond_I</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a183dd17d44d42e3d488e827b60449d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the infinity norm.  <a href="namespacefml_1_1linalg.html#a183dd17d44d42e3d488e827b60449d98">More...</a><br /></td></tr>
<tr class="separator:a183dd17d44d42e3d488e827b60449d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619bc1640a981611d62e315b24cb7c7c"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a619bc1640a981611d62e315b24cb7c7c"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a619bc1640a981611d62e315b24cb7c7c">cond_2</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a619bc1640a981611d62e315b24cb7c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the condition number under the 2 norm.  <a href="namespacefml_1_1linalg.html#a619bc1640a981611d62e315b24cb7c7c">More...</a><br /></td></tr>
<tr class="separator:a619bc1640a981611d62e315b24cb7c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6074b629194547169a6013c4d42a15"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4c6074b629194547169a6013c4d42a15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a4c6074b629194547169a6013c4d42a15">qr</a> (const bool pivot, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux)</td></tr>
<tr class="memdesc:a4c6074b629194547169a6013c4d42a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR decomposition.  <a href="namespacefml_1_1linalg.html#a4c6074b629194547169a6013c4d42a15">More...</a><br /></td></tr>
<tr class="separator:a4c6074b629194547169a6013c4d42a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fa311481ed062f64656229d7f0a28a"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab6fa311481ed062f64656229d7f0a28a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab6fa311481ed062f64656229d7f0a28a">qr_Q</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;QR, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:ab6fa311481ed062f64656229d7f0a28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a QR decomposition.  <a href="namespacefml_1_1linalg.html#ab6fa311481ed062f64656229d7f0a28a">More...</a><br /></td></tr>
<tr class="separator:ab6fa311481ed062f64656229d7f0a28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd684572d294c3bfa31a1d1fd09dc8"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aeccd684572d294c3bfa31a1d1fd09dc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aeccd684572d294c3bfa31a1d1fd09dc8">qr_R</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;QR, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="memdesc:aeccd684572d294c3bfa31a1d1fd09dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the R matrix from a QR decomposition.  <a href="namespacefml_1_1linalg.html#aeccd684572d294c3bfa31a1d1fd09dc8">More...</a><br /></td></tr>
<tr class="separator:aeccd684572d294c3bfa31a1d1fd09dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717675c09749146c74015542b839d0b8"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a717675c09749146c74015542b839d0b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a717675c09749146c74015542b839d0b8">lq</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux)</td></tr>
<tr class="memdesc:a717675c09749146c74015542b839d0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LQ decomposition.  <a href="namespacefml_1_1linalg.html#a717675c09749146c74015542b839d0b8">More...</a><br /></td></tr>
<tr class="separator:a717675c09749146c74015542b839d0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e09b1658320e29b57187150159eb448"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a2e09b1658320e29b57187150159eb448"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a2e09b1658320e29b57187150159eb448">lq_L</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;LQ, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;L)</td></tr>
<tr class="memdesc:a2e09b1658320e29b57187150159eb448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the L matrix from a LQ decomposition.  <a href="namespacefml_1_1linalg.html#a2e09b1658320e29b57187150159eb448">More...</a><br /></td></tr>
<tr class="separator:a2e09b1658320e29b57187150159eb448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a3a54aa4bd03d9b17a9b418e605af0"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a65a3a54aa4bd03d9b17a9b418e605af0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a65a3a54aa4bd03d9b17a9b418e605af0">lq_Q</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;LQ, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;lqaux, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;Q, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;work)</td></tr>
<tr class="memdesc:a65a3a54aa4bd03d9b17a9b418e605af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the Q matrix from a LQ decomposition.  <a href="namespacefml_1_1linalg.html#a65a3a54aa4bd03d9b17a9b418e605af0">More...</a><br /></td></tr>
<tr class="separator:a65a3a54aa4bd03d9b17a9b418e605af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b85a038f314f1b2f0f387d3a2f2969d"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4b85a038f314f1b2f0f387d3a2f2969d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a4b85a038f314f1b2f0f387d3a2f2969d">solve</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a4b85a038f314f1b2f0f387d3a2f2969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations.  <a href="namespacefml_1_1linalg.html#a4b85a038f314f1b2f0f387d3a2f2969d">More...</a><br /></td></tr>
<tr class="separator:a4b85a038f314f1b2f0f387d3a2f2969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac6c42169e30e8a7256bd67add09c4b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1ac6c42169e30e8a7256bd67add09c4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1ac6c42169e30e8a7256bd67add09c4b">qrsvd</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a1ac6c42169e30e8a7256bd67add09c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization.  <a href="namespacefml_1_1linalg.html#a1ac6c42169e30e8a7256bd67add09c4b">More...</a><br /></td></tr>
<tr class="separator:a1ac6c42169e30e8a7256bd67add09c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111b0473f2d3546c22550e74bbe21a39"><td class="memTemplParams" colspan="2"><a id="a111b0473f2d3546c22550e74bbe21a39"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a111b0473f2d3546c22550e74bbe21a39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a111b0473f2d3546c22550e74bbe21a39">qrsvd</a> (<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a111b0473f2d3546c22550e74bbe21a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a111b0473f2d3546c22550e74bbe21a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca0164d6993aa4523b9cc0e6de6bed"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a69ca0164d6993aa4523b9cc0e6de6bed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a69ca0164d6993aa4523b9cc0e6de6bed">cpsvd</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a69ca0164d6993aa4523b9cc0e6de6bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable.  <a href="namespacefml_1_1linalg.html#a69ca0164d6993aa4523b9cc0e6de6bed">More...</a><br /></td></tr>
<tr class="separator:a69ca0164d6993aa4523b9cc0e6de6bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23ebc612637ced7d0ef084e120f8b7d"><td class="memTemplParams" colspan="2"><a id="ab23ebc612637ced7d0ef084e120f8b7d"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ab23ebc612637ced7d0ef084e120f8b7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ab23ebc612637ced7d0ef084e120f8b7d">cpsvd</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:ab23ebc612637ced7d0ef084e120f8b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab23ebc612637ced7d0ef084e120f8b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cbe11afbd0141274f38cdb9e7baded"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae6cbe11afbd0141274f38cdb9e7baded"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ae6cbe11afbd0141274f38cdb9e7baded">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:ae6cbe11afbd0141274f38cdb9e7baded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation.  <a href="namespacefml_1_1linalg.html#ae6cbe11afbd0141274f38cdb9e7baded">More...</a><br /></td></tr>
<tr class="separator:ae6cbe11afbd0141274f38cdb9e7baded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932548eb84d824e46657d4736390bd43"><td class="memTemplParams" colspan="2"><a id="a932548eb84d824e46657d4736390bd43"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a932548eb84d824e46657d4736390bd43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a932548eb84d824e46657d4736390bd43">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a932548eb84d824e46657d4736390bd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a932548eb84d824e46657d4736390bd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780067acbd06a526e148e08dbd71cba0"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a780067acbd06a526e148e08dbd71cba0"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a780067acbd06a526e148e08dbd71cba0">trace</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a780067acbd06a526e148e08dbd71cba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace, i.e. the sum of the diagonal.  <a href="namespacefml_1_1linalg.html#a780067acbd06a526e148e08dbd71cba0">More...</a><br /></td></tr>
<tr class="separator:a780067acbd06a526e148e08dbd71cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d68d60ff6528f2f6cd4d78e7da71fdd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1d68d60ff6528f2f6cd4d78e7da71fdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1d68d60ff6528f2f6cd4d78e7da71fdd">xpose</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;tx)</td></tr>
<tr class="memdesc:a1d68d60ff6528f2f6cd4d78e7da71fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose out-of-place (i.e. in a copy).  <a href="namespacefml_1_1linalg.html#a1d68d60ff6528f2f6cd4d78e7da71fdd">More...</a><br /></td></tr>
<tr class="separator:a1d68d60ff6528f2f6cd4d78e7da71fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6efaf460c0c49ab839d04b4453e048"><td class="memTemplParams" colspan="2"><a id="acf6efaf460c0c49ab839d04b4453e048"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:acf6efaf460c0c49ab839d04b4453e048"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#acf6efaf460c0c49ab839d04b4453e048">xpose</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:acf6efaf460c0c49ab839d04b4453e048"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:acf6efaf460c0c49ab839d04b4453e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b81ad9ec9afe20eeede224590e8946"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a56b81ad9ec9afe20eeede224590e8946"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a56b81ad9ec9afe20eeede224590e8946">matmult</a> (const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a56b81ad9ec9afe20eeede224590e8946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a distributed and a non-distributed matrix whose result is distributed, or the transpose of a distributed matrix with a distributed matrix whose result is non-distributed.  <a href="namespacefml_1_1linalg.html#a56b81ad9ec9afe20eeede224590e8946">More...</a><br /></td></tr>
<tr class="separator:a56b81ad9ec9afe20eeede224590e8946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785b088e55412ff32531fde5cb898010"><td class="memTemplParams" colspan="2"><a id="a785b088e55412ff32531fde5cb898010"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a785b088e55412ff32531fde5cb898010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a785b088e55412ff32531fde5cb898010">matmult</a> (const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a785b088e55412ff32531fde5cb898010"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a785b088e55412ff32531fde5cb898010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede16fbb6f91c1f935bd2d219a93b504"><td class="memTemplParams" colspan="2"><a id="aede16fbb6f91c1f935bd2d219a93b504"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aede16fbb6f91c1f935bd2d219a93b504"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aede16fbb6f91c1f935bd2d219a93b504">matmult</a> (const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:aede16fbb6f91c1f935bd2d219a93b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aede16fbb6f91c1f935bd2d219a93b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac056c48627e5e76ce8fb049ffb8228f1"><td class="memTemplParams" colspan="2"><a id="ac056c48627e5e76ce8fb049ffb8228f1"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac056c48627e5e76ce8fb049ffb8228f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac056c48627e5e76ce8fb049ffb8228f1">matmult</a> (const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ac056c48627e5e76ce8fb049ffb8228f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac056c48627e5e76ce8fb049ffb8228f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa91fd076a5c734393d750af66cf2067"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:aaa91fd076a5c734393d750af66cf2067"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#aaa91fd076a5c734393d750af66cf2067">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:aaa91fd076a5c734393d750af66cf2067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacefml_1_1linalg.html#aaa91fd076a5c734393d750af66cf2067">More...</a><br /></td></tr>
<tr class="separator:aaa91fd076a5c734393d750af66cf2067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243397982d98228e50b92d677c93a20a"><td class="memTemplParams" colspan="2"><a id="a243397982d98228e50b92d677c93a20a"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a243397982d98228e50b92d677c93a20a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a243397982d98228e50b92d677c93a20a">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a243397982d98228e50b92d677c93a20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a243397982d98228e50b92d677c93a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b829318fdeefb13276aa6a8fed8daa"><td class="memTemplParams" colspan="2"><a id="a40b829318fdeefb13276aa6a8fed8daa"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a40b829318fdeefb13276aa6a8fed8daa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>qr_R</b> (const int root, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="separator:a40b829318fdeefb13276aa6a8fed8daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594d8d852d0c4d9a3127fe15e673e6e8"><td class="memTemplParams" colspan="2"><a id="a594d8d852d0c4d9a3127fe15e673e6e8"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a594d8d852d0c4d9a3127fe15e673e6e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>qr_Q</b> (<a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;Q)</td></tr>
<tr class="separator:a594d8d852d0c4d9a3127fe15e673e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac002922f371479c86c2e8cbc7617311b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac002922f371479c86c2e8cbc7617311b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac002922f371479c86c2e8cbc7617311b">cpsvd</a> (const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:ac002922f371479c86c2e8cbc7617311b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts
SVD". This method is not numerically stable.  <a href="namespacefml_1_1linalg.html#ac002922f371479c86c2e8cbc7617311b">More...</a><br /></td></tr>
<tr class="separator:ac002922f371479c86c2e8cbc7617311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2ef982ab5d07cbe88244b33887954e"><td class="memTemplParams" colspan="2"><a id="add2ef982ab5d07cbe88244b33887954e"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:add2ef982ab5d07cbe88244b33887954e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#add2ef982ab5d07cbe88244b33887954e">cpsvd</a> (const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:add2ef982ab5d07cbe88244b33887954e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:add2ef982ab5d07cbe88244b33887954e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e580c3749bdd0e1bbec57d842d6cb1b"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5e580c3749bdd0e1bbec57d842d6cb1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a5e580c3749bdd0e1bbec57d842d6cb1b">tssvd</a> (<a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a5e580c3749bdd0e1bbec57d842d6cb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization.  <a href="namespacefml_1_1linalg.html#a5e580c3749bdd0e1bbec57d842d6cb1b">More...</a><br /></td></tr>
<tr class="separator:a5e580c3749bdd0e1bbec57d842d6cb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48091f6843a14559708c2798d78d20f1"><td class="memTemplParams" colspan="2"><a id="a48091f6843a14559708c2798d78d20f1"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a48091f6843a14559708c2798d78d20f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a48091f6843a14559708c2798d78d20f1">tssvd</a> (<a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a48091f6843a14559708c2798d78d20f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a48091f6843a14559708c2798d78d20f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fab87cdc56206c2ece2d79b969ea37"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a87fab87cdc56206c2ece2d79b969ea37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a87fab87cdc56206c2ece2d79b969ea37">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a87fab87cdc56206c2ece2d79b969ea37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation.  <a href="namespacefml_1_1linalg.html#a87fab87cdc56206c2ece2d79b969ea37">More...</a><br /></td></tr>
<tr class="separator:a87fab87cdc56206c2ece2d79b969ea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883df459a99186b663dede0a8a8cd67a"><td class="memTemplParams" colspan="2"><a id="a883df459a99186b663dede0a8a8cd67a"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a883df459a99186b663dede0a8a8cd67a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a883df459a99186b663dede0a8a8cd67a">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a883df459a99186b663dede0a8a8cd67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a883df459a99186b663dede0a8a8cd67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f0bcbd83e2bdd1ad0cce068b7df17"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a131f0bcbd83e2bdd1ad0cce068b7df17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a131f0bcbd83e2bdd1ad0cce068b7df17">matmult</a> (const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a131f0bcbd83e2bdd1ad0cce068b7df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a distributed and a non-distributed matrix whose result is distributed, or the transpose of a distributed matrix with a distributed matrix whose result is non-distributed.  <a href="namespacefml_1_1linalg.html#a131f0bcbd83e2bdd1ad0cce068b7df17">More...</a><br /></td></tr>
<tr class="separator:a131f0bcbd83e2bdd1ad0cce068b7df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9f090679d6da1c1a9ab2eccf616ca1"><td class="memTemplParams" colspan="2"><a id="a4d9f090679d6da1c1a9ab2eccf616ca1"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4d9f090679d6da1c1a9ab2eccf616ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a4d9f090679d6da1c1a9ab2eccf616ca1">matmult</a> (const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:a4d9f090679d6da1c1a9ab2eccf616ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a4d9f090679d6da1c1a9ab2eccf616ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ba31945222454912b59451d8762d9e"><td class="memTemplParams" colspan="2"><a id="ac6ba31945222454912b59451d8762d9e"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac6ba31945222454912b59451d8762d9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac6ba31945222454912b59451d8762d9e">matmult</a> (const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;y, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:ac6ba31945222454912b59451d8762d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac6ba31945222454912b59451d8762d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bab8e7c06cc62352d4e78aaad3ef99"><td class="memTemplParams" colspan="2"><a id="ac9bab8e7c06cc62352d4e78aaad3ef99"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac9bab8e7c06cc62352d4e78aaad3ef99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac9bab8e7c06cc62352d4e78aaad3ef99">matmult</a> (const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;y)</td></tr>
<tr class="memdesc:ac9bab8e7c06cc62352d4e78aaad3ef99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac9bab8e7c06cc62352d4e78aaad3ef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1470d3db57d95e7493c1938a408bbf51"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1470d3db57d95e7493c1938a408bbf51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1470d3db57d95e7493c1938a408bbf51">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;ret)</td></tr>
<tr class="memdesc:a1470d3db57d95e7493c1938a408bbf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes lower triangle of alpha*x^T*x.  <a href="namespacefml_1_1linalg.html#a1470d3db57d95e7493c1938a408bbf51">More...</a><br /></td></tr>
<tr class="separator:a1470d3db57d95e7493c1938a408bbf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae850ddccf4a908b690cb728d14234468"><td class="memTemplParams" colspan="2"><a id="ae850ddccf4a908b690cb728d14234468"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ae850ddccf4a908b690cb728d14234468"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ae850ddccf4a908b690cb728d14234468">crossprod</a> (const REAL alpha, const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:ae850ddccf4a908b690cb728d14234468"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae850ddccf4a908b690cb728d14234468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f109359b52dc3b2f545474773731a38"><td class="memTemplParams" colspan="2"><a id="a4f109359b52dc3b2f545474773731a38"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a4f109359b52dc3b2f545474773731a38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>qr_R</b> (const int root, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;R)</td></tr>
<tr class="separator:a4f109359b52dc3b2f545474773731a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708d453de7c59f361cdbc3cafb69c7d1"><td class="memTemplParams" colspan="2"><a id="a708d453de7c59f361cdbc3cafb69c7d1"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a708d453de7c59f361cdbc3cafb69c7d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>qr_Q</b> (<a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;qraux, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;Q)</td></tr>
<tr class="separator:a708d453de7c59f361cdbc3cafb69c7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ade37d71bec5c7573c3dc8ea727bf7"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a26ade37d71bec5c7573c3dc8ea727bf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a26ade37d71bec5c7573c3dc8ea727bf7">cpsvd</a> (const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a26ade37d71bec5c7573c3dc8ea727bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition using the "crossproducts
SVD". This method is not numerically stable.  <a href="namespacefml_1_1linalg.html#a26ade37d71bec5c7573c3dc8ea727bf7">More...</a><br /></td></tr>
<tr class="separator:a26ade37d71bec5c7573c3dc8ea727bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0cad5fcd77891c2fb9b728895bec60"><td class="memTemplParams" colspan="2"><a id="a1b0cad5fcd77891c2fb9b728895bec60"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a1b0cad5fcd77891c2fb9b728895bec60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a1b0cad5fcd77891c2fb9b728895bec60">cpsvd</a> (const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:a1b0cad5fcd77891c2fb9b728895bec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a1b0cad5fcd77891c2fb9b728895bec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b6e6c6ba25677a2c37b519a7cdcefd"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a42b6e6c6ba25677a2c37b519a7cdcefd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a42b6e6c6ba25677a2c37b519a7cdcefd">tssvd</a> (<a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a42b6e6c6ba25677a2c37b519a7cdcefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization.  <a href="namespacefml_1_1linalg.html#a42b6e6c6ba25677a2c37b519a7cdcefd">More...</a><br /></td></tr>
<tr class="separator:a42b6e6c6ba25677a2c37b519a7cdcefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cd87e83d69f05120e7d9f82f624352"><td class="memTemplParams" colspan="2"><a id="ac4cd87e83d69f05120e7d9f82f624352"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:ac4cd87e83d69f05120e7d9f82f624352"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#ac4cd87e83d69f05120e7d9f82f624352">tssvd</a> (<a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:ac4cd87e83d69f05120e7d9f82f624352"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac4cd87e83d69f05120e7d9f82f624352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fc2f09c4c04f6b6be0f592994fb95"><td class="memTemplParams" colspan="2">template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:a5e1fc2f09c4c04f6b6be0f592994fb95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#a5e1fc2f09c4c04f6b6be0f592994fb95">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s)</td></tr>
<tr class="memdesc:a5e1fc2f09c4c04f6b6be0f592994fb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation.  <a href="namespacefml_1_1linalg.html#a5e1fc2f09c4c04f6b6be0f592994fb95">More...</a><br /></td></tr>
<tr class="separator:a5e1fc2f09c4c04f6b6be0f592994fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe6930ae5e703f12f810b3bf3146031"><td class="memTemplParams" colspan="2"><a id="affe6930ae5e703f12f810b3bf3146031"></a>
template&lt;typename REAL &gt; </td></tr>
<tr class="memitem:affe6930ae5e703f12f810b3bf3146031"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefml_1_1linalg.html#affe6930ae5e703f12f810b3bf3146031">rsvd</a> (const uint32_t seed, const int k, const int q, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;x, <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;s, <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;u, <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;vt)</td></tr>
<tr class="memdesc:affe6930ae5e703f12f810b3bf3146031"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:affe6930ae5e703f12f810b3bf3146031"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af31fc17f7e8fcb2d219c2c6071066089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31fc17f7e8fcb2d219c2c6071066089">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for the sum, the method will throw a 'runtime_error' exception.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa02a3f6e65195feca81a0b76024caf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02a3f6e65195feca81a0b76024caf38">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for the sum, the method will throw a 'runtime_error' exception.</p>
<p><b>Implementation Details</b><br  />
 Uses the cuBLAS function <code>cublasXgeam()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac3b2bfdd57e2f1aa167cc21260741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac3b2bfdd57e2f1aa167cc21260741f">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x) + beta*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha,beta</td><td>Scalars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>The inputs to the sum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The sum.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for the sum, the method will throw a 'runtime_error' exception.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<p><b>Implementation Details</b><br  />
 Uses the PBLAS function <code>pXgeadd()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a781eb9009441462d4a1fbe6c5a9742ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781eb9009441462d4a1fbe6c5a9742ef">&#9670;&nbsp;</a></span>chol() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Choleski factorization. </p>
<p>The matrix should be 1. square, 2. symmetric, 3. positive-definite. Failure of any of these conditions can lead to a runtime exception. The input is replaced by its lower-triangular Choleski factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its lower-triangular Choleski factor.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xpotrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 Some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a975107e72bac0267373ea0b4a85941bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975107e72bac0267373ea0b4a85941bf">&#9670;&nbsp;</a></span>chol() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Choleski factorization. </p>
<p>The matrix should be 1. square, 2. symmetric, 3. positive-definite. Failure of any of these conditions can lead to a runtime exception. The input is replaced by its lower-triangular Choleski factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its lower-triangular Choleski factor.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses the cuSOLVER function <code>cusolverDnXpotrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 Some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55c9aac32d61af8902f7e9e842aba1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55c9aac32d61af8902f7e9e842aba1e">&#9670;&nbsp;</a></span>chol() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Choleski factorization. </p>
<p>The matrix should be 1. square, 2. symmetric, 3. positive-definite. Failure of any of these conditions can lead to a runtime exception. The input is replaced by its lower-triangular Choleski factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its lower-triangular Choleski factor.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXpotrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 Some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86cf5688ee5a622e134ab6d931224798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cf5688ee5a622e134ab6d931224798">&#9670;&nbsp;</a></span>cond_1() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the 1-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Computes L or R (whichever is smaller) and the LAPACK function <code>Xtrcon()</code> if the input is not square, and <code>Xgecon()</code> on the LU of the input otherwise.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f55b08f07cd12665eaf13d02178ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f55b08f07cd12665eaf13d02178ca27">&#9670;&nbsp;</a></span>cond_1() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the 1-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Computes L or R (whichever is smaller) if the input is not square, and the inverse otherwise.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17d99edb5e8bc0f6374e67a201611961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d99edb5e8bc0f6374e67a201611961">&#9670;&nbsp;</a></span>cond_1() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the 1-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Computes L or R (whichever is smaller) and the LAPACK function <code>Xtrcon()</code> if the input is not square, and <code>Xgecon()</code> on the LU of the input otherwise.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3682f138b81b2e77122061fb87ac6192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3682f138b81b2e77122061fb87ac6192">&#9670;&nbsp;</a></span>cond_2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the 2 norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad02363e50589c4f8256500b83dbd2797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02363e50589c4f8256500b83dbd2797">&#9670;&nbsp;</a></span>cond_2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the 2 norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a08ba317b627fa84ca085686faecf91e5" title="Computes the singular value decomposition using the &quot;crossproducts SVD&quot;. This method is not numerical...">linalg::cpsvd()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a619bc1640a981611d62e315b24cb7c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619bc1640a981611d62e315b24cb7c7c">&#9670;&nbsp;</a></span>cond_2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the 2 norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7387112b58428e080d403e2edb94e76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7387112b58428e080d403e2edb94e76b">&#9670;&nbsp;</a></span>cond_I() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_I </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the infinity norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Computes L or R (whichever is smaller) and the LAPACK function <code>Xtrcon()</code> if the input is not square, and <code>Xgecon()</code> on the LU of the input otherwise.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0071ae9f6409026e92ba734112ba0285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0071ae9f6409026e92ba734112ba0285">&#9670;&nbsp;</a></span>cond_I() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_I </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the infinity norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Computes L or R (whichever is smaller) if the input is not square, and the inverse otherwise.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183dd17d44d42e3d488e827b60449d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183dd17d44d42e3d488e827b60449d98">&#9670;&nbsp;</a></span>cond_I() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::cond_I </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the condition number under the infinity norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. The data is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Computes L or R (whichever is smaller) and the LAPACK function <code>Xtrcon()</code> if the input is not square, and <code>Xgecon()</code> on the LU of the input otherwise.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the QR/LQ/LU, as well as workspace arrays for the LAPACK condition number function.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ba317b627fa84ca085686faecf91e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ba317b627fa84ca085686faecf91e5">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X or X * X^T (whichever is smaller) and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a1932a6365c1b910d332ea2c036500ee4" title="Computes lower triangle of alpha*x^T*x.">crossprod()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a75d93a2c70ff9521879669e53d772c7d" title="Computes lower triangle of alpha*x*x^T.">tcrossprod()</a></code> (whichever is smaller), and <code><a class="el" href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">eigen_sym()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17472ad16a3a5b46bb5fa67b1b3c58a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17472ad16a3a5b46bb5fa67b1b3c58a6">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X or X * X^T (whichever is smaller) and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a1932a6365c1b910d332ea2c036500ee4" title="Computes lower triangle of alpha*x^T*x.">crossprod()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a75d93a2c70ff9521879669e53d772c7d" title="Computes lower triangle of alpha*x*x^T.">tcrossprod()</a></code> (whichever is smaller), and <code><a class="el" href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">eigen_sym()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69ca0164d6993aa4523b9cc0e6de6bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ca0164d6993aa4523b9cc0e6de6bed">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X or X * X^T (whichever is smaller) and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a1932a6365c1b910d332ea2c036500ee4" title="Computes lower triangle of alpha*x^T*x.">crossprod()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a75d93a2c70ff9521879669e53d772c7d" title="Computes lower triangle of alpha*x*x^T.">tcrossprod()</a></code> (whichever is smaller), and <code><a class="el" href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">eigen_sym()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac002922f371479c86c2e8cbc7617311b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac002922f371479c86c2e8cbc7617311b">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts
SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a crossproduct which requires communication, followed by a local <code><a class="el" href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">linalg::eigen_sym()</a></code> call.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26ade37d71bec5c7573c3dc8ea727bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ade37d71bec5c7573c3dc8ea727bf7">&#9670;&nbsp;</a></span>cpsvd() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::cpsvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition using the "crossproducts
SVD". This method is not numerically stable. </p>
<p>The operation works by computing the crossproducts matrix X^T * X and then computing the eigenvalue decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a crossproduct which requires communication, followed by a local <code><a class="el" href="namespacefml_1_1linalg.html#afe6aba84a7e95dbdeb614b3f8f70cdce" title="Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix.">linalg::eigen_sym()</a></code> call.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1932a6365c1b910d332ea2c036500ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1932a6365c1b910d332ea2c036500ee4">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a396b1ddbdb20fe8e5b62eb104eb47e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396b1ddbdb20fe8e5b62eb104eb47e9c">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuBLAS function <code>cublasXsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11f1f1a03b2ca66ae42893e51bd69d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f1f1a03b2ca66ae42893e51bd69d65">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>pXsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa91fd076a5c734393d750af66cf2067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa91fd076a5c734393d750af66cf2067">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1470d3db57d95e7493c1938a408bbf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1470d3db57d95e7493c1938a408bbf51">&#9670;&nbsp;</a></span>crossprod() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::crossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x^T*x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b7ecd011326b0b115562dd9dcf391fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7ecd011326b0b115562dd9dcf391fb">&#9670;&nbsp;</a></span>det() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::det </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant in logarithmic form. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign</td><td>The sign of the determinant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modulus</td><td>Log of the modulus.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a05637620851fd435dcf11d50a0fdc782" title="Computes the PLU factorization with partial pivoting.">lu()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the LU.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19f79bc22832caf30b170e2f0796bca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f79bc22832caf30b170e2f0796bca2">&#9670;&nbsp;</a></span>det() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::det </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant in logarithmic form. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign</td><td>The sign of the determinant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modulus</td><td>Log of the modulus.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a05637620851fd435dcf11d50a0fdc782" title="Computes the PLU factorization with partial pivoting.">lu()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the LU.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d87be93e642f5f4b5d2176fb855bf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d87be93e642f5f4b5d2176fb855bf32">&#9670;&nbsp;</a></span>det() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::det </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant in logarithmic form. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign</td><td>The sign of the determinant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modulus</td><td>Log of the modulus.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a05637620851fd435dcf11d50a0fdc782" title="Computes the PLU factorization with partial pivoting.">lu()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the LU.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a631534e78495dbdaf5dd94df17bedda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631534e78495dbdaf5dd94df17bedda3">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the dot product of two vectors, i.e. the sum of the product of the elements. </p>
<p>NOTE: if the vectors are of different length, the dot product will use only the indices of the smaller-sized vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>Vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double' ('int' is also ok). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11feb45b302a0bf02ef712899d4dafc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11feb45b302a0bf02ef712899d4dafc3">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the dot product of two vectors, i.e. the sum of the product of the elements. </p>
<p>NOTE: if the vectors are of different length, the dot product will use only the indices of the smaller-sized vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>Vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe6aba84a7e95dbdeb614b3f8f70cdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6aba84a7e95dbdeb614b3f8f70cdce">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK functions <code>Xsyevr()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If any output's dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b4c23508e3b9382368f83f4212595ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4c23508e3b9382368f83f4212595ce">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER functions <code>cusolverDnXsyevd()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If any output's dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab11d2ad0dc980fa3feb70ca118b6165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab11d2ad0dc980fa3feb70ca118b6165">&#9670;&nbsp;</a></span>eigen_sym() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::eigen_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and optionally the eigenvectors for a symmetric matrix. </p>
<p>The input data is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK functions <code>pXsyevr()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If any output's dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f00674f4d70ea3199fdcec3531e4397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f00674f4d70ea3199fdcec3531e4397">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK functions <code>Xgetrf()</code> (LU) and <code>Xgetri()</code> (solve).</p>
<p><b>Memory Allocations</b><br  />
 LU pivot data is allocated internally.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a442ad9b632db67a7a25c25ad517af908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442ad9b632db67a7a25c25ad517af908">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER functions <code>cusolverDnXgetrf()</code> (LU) and <code>cusolverDnXgetrs()</code> (solve).</p>
<p><b>Memory Allocations</b><br  />
 LU pivot data is allocated internally. The inverse is computed in a copy before copying back to the input.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adedd514e600cdd1a66ff400a6493d72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedd514e600cdd1a66ff400a6493d72e">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse. </p>
<p>The input is replaced by its inverse, computed via a PLU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK functions <code>pXgetrf()</code> (LU) and <code>pXgetri()</code> (solve).</p>
<p><b>Memory Allocations</b><br  />
 LU pivot data is allocated internally.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a442c95b5a165469a61f5bc5822b016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442c95b5a165469a61f5bc5822b016f2">&#9670;&nbsp;</a></span>lq() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LQ decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact LQ representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xgelqf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312232cff8743c9075762eb228d3edf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312232cff8743c9075762eb228d3edf7">&#9670;&nbsp;</a></span>lq() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LQ decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact LQ representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 NOTE: not directly supported by cuSOLVER (vendor gpulapack + cuda backend). In that case, the matrix is transposed and a QR is performed.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717675c09749146c74015542b839d0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717675c09749146c74015542b839d0b8">&#9670;&nbsp;</a></span>lq() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LQ decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact LQ representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXgelqf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b3fb47aba762c3ea659190d20fca5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3fb47aba762c3ea659190d20fca5eb">&#9670;&nbsp;</a></span>lq_L() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq_L </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the L matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>The L matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xlacpy()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58babcaf925f2998df1ebbcbaaa680c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58babcaf925f2998df1ebbcbaaa680c0">&#9670;&nbsp;</a></span>lq_L() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq_L </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the L matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>The L matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 NOTE: not directly supported by cuSOLVER (vendor gpulapack + cuda backend). In that case, the matrix is transposed and a QR is performed.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e09b1658320e29b57187150159eb448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e09b1658320e29b57187150159eb448">&#9670;&nbsp;</a></span>lq_L() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq_L </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the L matrix from a LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>The L matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXlacpy()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91eacd684f4c6ea99d681007b610d659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91eacd684f4c6ea99d681007b610d659">&#9670;&nbsp;</a></span>lq_Q() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xorglq()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4898b487932411e56ac94d42bfd81647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4898b487932411e56ac94d42bfd81647">&#9670;&nbsp;</a></span>lq_Q() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from an LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 NOTE: not directly supported by cuSOLVER (vendor gpulapack + cuda backend). In that case, the matrix is transposed and a QR is performed.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65a3a54aa4bd03d9b17a9b418e605af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a3a54aa4bd03d9b17a9b418e605af0">&#9670;&nbsp;</a></span>lq_Q() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lq_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>LQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lqaux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a LQ decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LQ</td><td>The compact LQ factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">lq()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lqaux</td><td>Auxiliary data for compact LQ. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXorglq()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05637620851fd435dcf11d50a0fdc782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05637620851fd435dcf11d50a0fdc782">&#9670;&nbsp;</a></span>lu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xgetrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the pivot vector is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8e637b5cf435c79755089664d9aae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e637b5cf435c79755089664d9aae1e">&#9670;&nbsp;</a></span>lu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The LAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER function <code>cusolverDnXgetrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the pivot vector is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19473e478ddbca6b04ba74e4ab0e437b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19473e478ddbca6b04ba74e4ab0e437b">&#9670;&nbsp;</a></span>lu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the PLU factorization with partial pivoting. </p>
<p>The input is replaced by its LU factorization, with L unit-diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Vector of pivots, representing the diagonal matrix P in the PLU. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The ScaLAPACK return number.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXgetrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the pivot vector is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a550d8e6383cfa7f4e000d35c7f834bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550d8e6383cfa7f4e000d35c7f834bc4">&#9670;&nbsp;</a></span>matmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</p>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xgemm()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6460ba90776e3b8589448edc887791dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6460ba90776e3b8589448edc887791dd">&#9670;&nbsp;</a></span>matmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</p>
<p><b>Implementation Details</b><br  />
 Uses the cuBLAS function <code>cublasXgemm()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a218a6b09807150aaf820e95049124ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218a6b09807150aaf820e95049124ce3">&#9670;&nbsp;</a></span>matmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt;REAL&gt; fml::linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown.</p>
<p><b>Implementation Details</b><br  />
 Uses the PBLAS function <code>pXgemm()</code>.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add560d8d285bd77f22108a8f08fb8aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add560d8d285bd77f22108a8f08fb8aa0">&#9670;&nbsp;</a></span>matmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ret = alpha*op(x)*op(y) where op(A) is A or A^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transx</td><td>Should x^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transy</td><td>Should y^T be used? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown.</p>
<p><b>Implementation Details</b><br  />
 Uses the PBLAS function <code>pXgemm()</code>.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b81ad9ec9afe20eeede224590e8946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b81ad9ec9afe20eeede224590e8946">&#9670;&nbsp;</a></span>matmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of a distributed and a non-distributed matrix whose result is distributed, or the transpose of a distributed matrix with a distributed matrix whose result is non-distributed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</p>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xgemm()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a131f0bcbd83e2bdd1ad0cce068b7df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131f0bcbd83e2bdd1ad0cce068b7df17">&#9670;&nbsp;</a></span>matmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::matmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of a distributed and a non-distributed matrix whose result is distributed, or the transpose of a distributed matrix with a distributed matrix whose result is non-distributed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Left multiplicand. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Right multiplicand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If x and y are inappropriately sized for a matrix product, the method will throw a 'runtime_error' exception.</p>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xgemm()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a153505fe39cf6c8d37acf40c179c3edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153505fe39cf6c8d37acf40c179c3edf">&#9670;&nbsp;</a></span>norm_1() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 1 matrix norm, the maximum absolute column sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f08a68f10da4b7f771ac48051877fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f08a68f10da4b7f771ac48051877fcd">&#9670;&nbsp;</a></span>norm_1() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 1 matrix norm, the maximum absolute column sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to store the col sums.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37a8bc4594a3ac1bcfd74bcf3b4c9b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a8bc4594a3ac1bcfd74bcf3b4c9b3d">&#9670;&nbsp;</a></span>norm_1() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 1 matrix norm, the maximum absolute column sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to store the col sums.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f1cc321073c3a24f287fcf27ee32e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1cc321073c3a24f287fcf27ee32e33">&#9670;&nbsp;</a></span>norm_2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 2/spectral matrix norm. </p>
<p>Returns the largest singular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the singular values.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d04f6add456b7f8103acca0029df4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d04f6add456b7f8103acca0029df4af">&#9670;&nbsp;</a></span>norm_2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 2/spectral matrix norm. </p>
<p>Returns the largest singular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a08ba317b627fa84ca085686faecf91e5" title="Computes the singular value decomposition using the &quot;crossproducts SVD&quot;. This method is not numerical...">linalg::cpsvd()</a></code>.</p>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the singular values.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a263c1fe506add0870e09c033c5ebabc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263c1fe506add0870e09c033c5ebabc3">&#9670;&nbsp;</a></span>norm_2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 2/spectral matrix norm. </p>
<p>Returns the largest singular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to compute the singular values.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a059b5a8032b13cf243ee1d4a45d61520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059b5a8032b13cf243ee1d4a45d61520">&#9670;&nbsp;</a></span>norm_F() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_F </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Frobenius/Euclidean matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f22ad24144c16f456991725554200a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f22ad24144c16f456991725554200a4">&#9670;&nbsp;</a></span>norm_F() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_F </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Frobenius/Euclidean matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a112c5c64cea35eaed6a4d3af39aebb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112c5c64cea35eaed6a4d3af39aebb29">&#9670;&nbsp;</a></span>norm_F() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_F </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Frobenius/Euclidean matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5718aa3b49c71f79bc99cbdfa23024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5718aa3b49c71f79bc99cbdfa23024f">&#9670;&nbsp;</a></span>norm_I() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_I </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the infinity matrix norm, the maximum absolute row sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to store the row sums.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1482019ffd17d65a353e0f2d40074bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1482019ffd17d65a353e0f2d40074bd0">&#9670;&nbsp;</a></span>norm_I() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_I </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the infinity matrix norm, the maximum absolute row sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to store the row sums.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35a5dcdfd1aebe704f96550b0bb1b126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a5dcdfd1aebe704f96550b0bb1b126">&#9670;&nbsp;</a></span>norm_I() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_I </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the infinity matrix norm, the maximum absolute row sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<p><b>Memory Allocations</b><br  />
 Allocates temporary storage to store the row sums.</p>
<p><b>Exceptions</b><br  />
 If an allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164e31e7701f67c1be948f730347a6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164e31e7701f67c1be948f730347a6de">&#9670;&nbsp;</a></span>norm_M() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_M </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum modulus matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff467914d49d644b77c795e2f63219d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff467914d49d644b77c795e2f63219d9">&#9670;&nbsp;</a></span>norm_M() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_M </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum modulus matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac562dabd4ca5decaa33b72f16b254624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac562dabd4ca5decaa33b72f16b254624">&#9670;&nbsp;</a></span>norm_M() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::norm_M </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum modulus matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix, replaced by its LU factorization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17f00a119a389317d318fdaab558c67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f00a119a389317d318fdaab558c67d">&#9670;&nbsp;</a></span>qr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact QR representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot</td><td>Should the factorization use column pivoting? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xgeqp3()</code> if pivoting and <code>Xgeqrf()</code> otherwise.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32f327d0a2bf45c9bf61f1cafa34fccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f327d0a2bf45c9bf61f1cafa34fccd">&#9670;&nbsp;</a></span>qr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact QR representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot</td><td>NOTE Pivoting does not yet work on GPU. Should the factorization use column pivoting? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER function <code>cusolverDnXgeqrf()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6074b629194547169a6013c4d42a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6074b629194547169a6013c4d42a15">&#9670;&nbsp;</a></span>qr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR decomposition. </p>
<p>The factorization works mostly in-place by modifying the input data. After execution, the matrix will be the LAPACK-like compact QR representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot</td><td>Should the factorization use column pivoting? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXgeqpf()</code> if pivoting and <code>pXgeqrf()</code> otherwise.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41161525467b9696c1b1083e738f13ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41161525467b9696c1b1083e738f13ec">&#9670;&nbsp;</a></span>qr_Q() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xorgqr()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bd1fb6ea4956410f9673d87d8435cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd1fb6ea4956410f9673d87d8435cfa">&#9670;&nbsp;</a></span>qr_Q() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER function <code>cusolverDnXorgqr()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6fa311481ed062f64656229d7f0a28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fa311481ed062f64656229d7f0a28a">&#9670;&nbsp;</a></span>qr_Q() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>qraux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the Q matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qraux</td><td>Auxiliary data for compact QR. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Q matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>Workspace array. Will be resized as necessary.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXormgr()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36c66bb960a01eb48d2179dff06a8922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c66bb960a01eb48d2179dff06a8922">&#9670;&nbsp;</a></span>qr_R() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr_R </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the R matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>The R matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xlacpy()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b146af4d02d8fd2d633af125081b8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b146af4d02d8fd2d633af125081b8dc">&#9670;&nbsp;</a></span>qr_R() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr_R </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the R matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>The R matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a custom LAPACK-like <code>lacpy()</code> clone.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeccd684572d294c3bfa31a1d1fd09dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccd684572d294c3bfa31a1d1fd09dc8">&#9670;&nbsp;</a></span>qr_R() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qr_R </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover the R matrix from a QR decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">QR</td><td>The compact QR factorization, as computed via <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">qr()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>The R matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK function <code>pXlacpy()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75fce75514b99aca5b2789820191059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fce75514b99aca5b2789820191059f">&#9670;&nbsp;</a></span>qrsvd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qrsvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization. </p>
<p>If the matrix has more rows than columns, the operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD. Likewise, if the matrix has more columns than rows, w take the LQ and then the SVD of the L matrix. The left singular vectors are Q times the right singular vectors from L's SVD, and the singular value and the left singular vectors are those from L's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">linalg::qr()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">linalg::lq()</a></code> (whichever is cheaper) to reduce the matrix to a square matrix, and then calls <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>. If computing the vectors, <code><a class="el" href="namespacefml_1_1linalg.html#a41161525467b9696c1b1083e738f13ec" title="Recover the Q matrix from a QR decomposition.">linalg::qr_Q()</a></code> and <code><a class="el" href="namespacefml_1_1linalg.html#a36c66bb960a01eb48d2179dff06a8922" title="Recover the R matrix from a QR decomposition.">linalg::qr_R()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a3b3fb47aba762c3ea659190d20fca5eb" title="Recover the L matrix from an LQ decomposition.">linalg::lq_L()</a></code> and <code><a class="el" href="namespacefml_1_1linalg.html#a91eacd684f4c6ea99d681007b610d659" title="Recover the Q matrix from an LQ decomposition.">linalg::lq_Q()</a></code> are called.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d551221bfb1be0037c55d1c4645da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d551221bfb1be0037c55d1c4645da6">&#9670;&nbsp;</a></span>qrsvd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qrsvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization. </p>
<p>If the matrix has more rows than columns, the operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD. Likewise, if the matrix has more columns than rows, w take the LQ and then the SVD of the L matrix. The left singular vectors are Q times the right singular vectors from L's SVD, and the singular value and the left singular vectors are those from L's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">linalg::qr()</a></code> to reduce the matrix to a square matrix, and then calls <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>. If computing the vectors, <code><a class="el" href="namespacefml_1_1linalg.html#a41161525467b9696c1b1083e738f13ec" title="Recover the Q matrix from a QR decomposition.">linalg::qr_Q()</a></code> and <code><a class="el" href="namespacefml_1_1linalg.html#a36c66bb960a01eb48d2179dff06a8922" title="Recover the R matrix from a QR decomposition.">linalg::qr_R()</a></code>. Since cuSOLVER only offers QR, if m&lt;n we operate on a transpose.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ac6c42169e30e8a7256bd67add09c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac6c42169e30e8a7256bd67add09c4b">&#9670;&nbsp;</a></span>qrsvd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::qrsvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization. </p>
<p>If the matrix has more rows than columns, the operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD. Likewise, if the matrix has more columns than rows, w take the LQ and then the SVD of the L matrix. The left singular vectors are Q times the right singular vectors from L's SVD, and the singular value and the left singular vectors are those from L's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses <code><a class="el" href="namespacefml_1_1linalg.html#a17f00a119a389317d318fdaab558c67d" title="Computes the QR decomposition.">linalg::qr()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a442c95b5a165469a61f5bc5822b016f2" title="Computes the LQ decomposition.">linalg::lq()</a></code> (whichever is cheaper) to reduce the matrix to a square matrix, and then calls <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>. If computing the vectors, <code><a class="el" href="namespacefml_1_1linalg.html#a41161525467b9696c1b1083e738f13ec" title="Recover the Q matrix from a QR decomposition.">linalg::qr_Q()</a></code> and <code><a class="el" href="namespacefml_1_1linalg.html#a36c66bb960a01eb48d2179dff06a8922" title="Recover the R matrix from a QR decomposition.">linalg::qr_R()</a></code> or <code><a class="el" href="namespacefml_1_1linalg.html#a3b3fb47aba762c3ea659190d20fca5eb" title="Recover the L matrix from an LQ decomposition.">linalg::lq_L()</a></code> and <code><a class="el" href="namespacefml_1_1linalg.html#a91eacd684f4c6ea99d681007b610d659" title="Recover the Q matrix from an LQ decomposition.">linalg::lq_Q()</a></code> are called.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1da58b7dfd9cddfb4be7e2215b03a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1da58b7dfd9cddfb4be7e2215b03a8">&#9670;&nbsp;</a></span>rsvd() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::rsvd </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a series of QR's and matrix multiplications.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5808d941b1f4802a629b3d4da0620804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5808d941b1f4802a629b3d4da0620804">&#9670;&nbsp;</a></span>rsvd() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::rsvd </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a series of QR's and matrix multiplications.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6cbe11afbd0141274f38cdb9e7baded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cbe11afbd0141274f38cdb9e7baded">&#9670;&nbsp;</a></span>rsvd() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::rsvd </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a series of QR's and matrix multiplications.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87fab87cdc56206c2ece2d79b969ea37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fab87cdc56206c2ece2d79b969ea37">&#9670;&nbsp;</a></span>rsvd() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::rsvd </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a series of QR's using the TSQR implementation, and matrix multiplications.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1fc2f09c4c04f6b6be0f592994fb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1fc2f09c4c04f6b6be0f592994fb95">&#9670;&nbsp;</a></span>rsvd() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::rsvd </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the truncated singular value decomposition using the normal projections method of Halko et al. This method is only an approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses a series of QR's using the TSQR implementation, and matrix multiplications.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af35c383c81abcf4cc2231b5c3e11800e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35c383c81abcf4cc2231b5c3e11800e">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK functions <code>Xgesv()</code>.</p>
<p><b>Memory Allocations</b><br  />
 LU pivot data is allocated internally.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square or if the RHS is incompatible with the LHS, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50bf59ecc984eb120ef98a5eaf35a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50bf59ecc984eb120ef98a5eaf35a99">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its PLU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER functions <code>cusolverDnXgetrf()</code> (LU) and <code>cusolverDnXgetrs()</code> (solve).</p>
<p><b>Memory Allocations</b><br  />
 LU pivot data is allocated internally.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square or if the RHS is incompatible with the LHS, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b85a038f314f1b2f0f387d3a2f2969d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b85a038f314f1b2f0f387d3a2f2969d">&#9670;&nbsp;</a></span>solve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations. </p>
<p>The input is replaced by its LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input LHS. Should be square. Overwritten by LU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Input RHS. Overwritten by solution.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the ScaLAPACK functions <code>pXgesv()</code>.</p>
<p><b>Memory Allocations</b><br  />
 LU pivot data is allocated internally.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square or if the RHS is incompatible with the LHS, a <code>runtime_error</code> exception is thrown. If the inputs are distributed on different grids, a <code>runtime_exception</code> is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add583703d1c77a9f7236effb9b568f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add583703d1c77a9f7236effb9b568f23">&#9670;&nbsp;</a></span>svd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK function <code>Xgesvd()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add9475ced0bd576bfb9c05d7c0fffe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9475ced0bd576bfb9c05d7c0fffe0c">&#9670;&nbsp;</a></span>svd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singnular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuSOLVER function <code>cusolverDnXgesvd()</code>. Since cuSOLVER only supports the m&gt;=n case, if m&lt;n we operate on a transpose.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d93a2c70ff9521879669e53d772c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d93a2c70ff9521879669e53d772c7d">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the BLAS function <code>Xsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b75d2e7c76340e7a32cd34d5e1b3087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b75d2e7c76340e7a32cd34d5e1b3087">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuBLAS function <code>cublasXsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167161d3b790e902ef894e8764913c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167161d3b790e902ef894e8764913c65">&#9670;&nbsp;</a></span>tcrossprod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes lower triangle of alpha*x*x^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>The product.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the PBLAS function <code>pXsyrk()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0456e9ec3c112ed3a0ca27cff164686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0456e9ec3c112ed3a0ca27cff164686">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a239113c5267ec96f309b345366816f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239113c5267ec96f309b345366816f5c">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a780067acbd06a526e148e08dbd71cba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780067acbd06a526e148e08dbd71cba0">&#9670;&nbsp;</a></span>trace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL fml::linalg::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace, i.e. the sum of the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a273675041a86335869b1a06daab45d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273675041a86335869b1a06daab45d2a">&#9670;&nbsp;</a></span>trinv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::trinv </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unit_diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse of a triangular matrix. </p>
<p>The input is replaced by its inverse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>Should the upper triangle be used? Otherwise the lower triangle will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_diag</td><td>Is the input matrix unit diagonal? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK functions <code>Xtrtri()</code>.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d4060a5a0de65bcd984c288ea4e77e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4060a5a0de65bcd984c288ea4e77e5">&#9670;&nbsp;</a></span>trinv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::trinv </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unit_diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse of a triangular matrix. </p>
<p>The input is replaced by its inverse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>Should the upper triangle be used? Otherwise the lower triangle will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_diag</td><td>Is the input matrix unit diagonal? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuBLAS functions <code>cublasXtrsm()</code>.</p>
<p><b>Memory Allocations</b><br  />
 The inverse is computed in a copy.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown. If an allocation fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf8e370a6c1e4ba7935114a9efb3323b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8e370a6c1e4ba7935114a9efb3323b">&#9670;&nbsp;</a></span>trinv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::trinv </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unit_diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix inverse of a triangular matrix. </p>
<p>The input is replaced by its inverse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>Should the upper triangle be used? Otherwise the lower triangle will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_diag</td><td>Is the input matrix unit diagonal? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Should be square.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the LAPACK functions <code>Xtrtri()</code>.</p>
<p><b>Exceptions</b><br  />
 If the matrix is non-square, a <code>runtime_error</code> exception is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e580c3749bdd0e1bbec57d842d6cb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e580c3749bdd0e1bbec57d842d6cb1b">&#9670;&nbsp;</a></span>tssvd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::tssvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1parmat__cpu.html">parmat_cpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization. </p>
<p>If the matrix has more rows than columns, the operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD. Likewise, if the matrix has more columns than rows, w take the LQ and then the SVD of the L matrix. The left singular vectors are Q times the right singular vectors from L's SVD, and the singular value and the left singular vectors are those from L's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the TSQR implementation to reduce the matrix to a square matrix, and then calls <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>. If computing the vectors, <code><a class="el" href="namespacefml_1_1linalg.html#a273675041a86335869b1a06daab45d2a" title="Compute the matrix inverse of a triangular matrix.">linalg::trinv()</a></code> and a series of matrix multiplications are used.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42b6e6c6ba25677a2c37b519a7cdcefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b6e6c6ba25677a2c37b519a7cdcefd">&#9670;&nbsp;</a></span>tssvd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::tssvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1parmat__gpu.html">parmat_gpu</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition by first reducing the rectangular matrix to a square matrix using an orthogonal factorization. If the matrix is square, we skip the orthogonal factorization. </p>
<p>If the matrix has more rows than columns, the operation works by computing a QR and then taking the SVD of the R matrix. The left singular vectors are Q times the left singular vectors from R's SVD, and the singular value and the right singular vectors are those from R's SVD. Likewise, if the matrix has more columns than rows, w take the LQ and then the SVD of the L matrix. The left singular vectors are Q times the right singular vectors from L's SVD, and the singular value and the left singular vectors are those from L's SVD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Input data matrix. Values are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Vector of singular values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Matrix of left singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>Matrix of (transposed) right singular vectors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the TSQR implementation to reduce the matrix to a square matrix, and then calls <code><a class="el" href="namespacefml_1_1linalg.html#add583703d1c77a9f7236effb9b568f23" title="Computes the singular value decomposition.">linalg::svd()</a></code>. If computing the vectors, <code><a class="el" href="namespacefml_1_1linalg.html#a273675041a86335869b1a06daab45d2a" title="Compute the matrix inverse of a triangular matrix.">linalg::trinv()</a></code> and a series of matrix multiplications are used.</p>
<p><b>Memory Allocations</b><br  />
 If the any outputs are inappropriately sized, they will automatically be re-allocated. Additionally, some temporary work storage is needed.</p>
<p><b>Exceptions</b><br  />
 If a (re-)allocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e1b30c504d3d9b0f52c44bce972fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e1b30c504d3d9b0f52c44bce972fdf">&#9670;&nbsp;</a></span>xpose() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpumat.html">cpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2fb08fbc91d1ef95535349b764040ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fb08fbc91d1ef95535349b764040ff">&#9670;&nbsp;</a></span>xpose() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1gpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the cuBLAS function <code>cublasXgeam()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d68d60ff6528f2f6cd4d78e7da71fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d68d60ff6528f2f6cd4d78e7da71fdd">&#9670;&nbsp;</a></span>xpose() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fml::linalg::xpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the transpose out-of-place (i.e. in a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input data matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx</td><td>The transpose.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Implementation Details</b><br  />
 Uses the PBLAS function <code>pXtran()</code>.</p>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefml.html">fml</a></li><li class="navelem"><a class="el" href="namespacefml_1_1linalg.html">linalg</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
