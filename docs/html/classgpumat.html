<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fml: gpumat&lt; REAL &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fml_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fml
   &#160;<span id="projectnumber">0.1-0</span>
   </div>
   <div id="projectbrief">Fused Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgpumat.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classgpumat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gpumat&lt; REAL &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix class for data held on a single GPU.  
 <a href="classgpumat.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gpumat_8hh_source.html">gpumat.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gpumat&lt; REAL &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgpumat.png" usemap="#gpumat_3C_20REAL_20_3E_map" alt=""/>
  <map id="gpumat_3C_20REAL_20_3E_map" name="gpumat_3C_20REAL_20_3E_map">
<area href="classunimat.html" title="Base matrix class. Not meant for direct use. Instead see cpumat, gpumat, and mpimat. " alt="unimat&lt; REAL &gt;" shape="rect" coords="0,0,108,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c77c422b5a4b82574d04688f2b1de5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a6c77c422b5a4b82574d04688f2b1de5d">gpumat</a> (std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt; gpu)</td></tr>
<tr class="memdesc:a6c77c422b5a4b82574d04688f2b1de5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object with no internal allocated storage.  <a href="#a6c77c422b5a4b82574d04688f2b1de5d">More...</a><br /></td></tr>
<tr class="separator:a6c77c422b5a4b82574d04688f2b1de5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6a15bfcaaf9899cf384ba6f06484a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#acd6a15bfcaaf9899cf384ba6f06484a8">gpumat</a> (std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt; gpu, len_t <a class="el" href="classunimat.html#ad4b4b6f0d9de498f8ba27afb237601ba">nrows</a>, len_t <a class="el" href="classunimat.html#abb62a12023f61a32c5503e00a9c028db">ncols</a>)</td></tr>
<tr class="memdesc:acd6a15bfcaaf9899cf384ba6f06484a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object.  <a href="#acd6a15bfcaaf9899cf384ba6f06484a8">More...</a><br /></td></tr>
<tr class="separator:acd6a15bfcaaf9899cf384ba6f06484a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e70a7e554aae2073b31059364b6f2b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a7e70a7e554aae2073b31059364b6f2b1">gpumat</a> (std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt; gpu, REAL *data, len_t <a class="el" href="classunimat.html#ad4b4b6f0d9de498f8ba27afb237601ba">nrows</a>, len_t <a class="el" href="classunimat.html#abb62a12023f61a32c5503e00a9c028db">ncols</a>, bool free_on_destruct=false)</td></tr>
<tr class="memdesc:a7e70a7e554aae2073b31059364b6f2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object with inherited data. Essentially the same as using the minimal constructor and immediately calling the <code><a class="el" href="classgpumat.html#a6c3d1dc8761358f14ab2aa168e1402d8" title="Set the internal object storage to the specified array. ">inherit()</a></code> method.  <a href="#a7e70a7e554aae2073b31059364b6f2b1">More...</a><br /></td></tr>
<tr class="separator:a7e70a7e554aae2073b31059364b6f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21052318b31804b674485d548e79df04"><td class="memItemLeft" align="right" valign="top"><a id="a21052318b31804b674485d548e79df04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>gpumat</b> (const <a class="el" href="classgpumat.html">gpumat</a> &amp;x)</td></tr>
<tr class="separator:a21052318b31804b674485d548e79df04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad661c1de72bbee7b54b8196191f2c459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#ad661c1de72bbee7b54b8196191f2c459">resize</a> (len_t <a class="el" href="classunimat.html#ad4b4b6f0d9de498f8ba27afb237601ba">nrows</a>, len_t <a class="el" href="classunimat.html#abb62a12023f61a32c5503e00a9c028db">ncols</a>)</td></tr>
<tr class="memdesc:ad661c1de72bbee7b54b8196191f2c459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the internal object storage.  <a href="#ad661c1de72bbee7b54b8196191f2c459">More...</a><br /></td></tr>
<tr class="separator:ad661c1de72bbee7b54b8196191f2c459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da36c8111d0b80228eb1560cfc31ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a6da36c8111d0b80228eb1560cfc31ddd">resize</a> (std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt; gpu, len_t <a class="el" href="classunimat.html#ad4b4b6f0d9de498f8ba27afb237601ba">nrows</a>, len_t <a class="el" href="classunimat.html#abb62a12023f61a32c5503e00a9c028db">ncols</a>)</td></tr>
<tr class="memdesc:a6da36c8111d0b80228eb1560cfc31ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the internal object storage.  <a href="#a6da36c8111d0b80228eb1560cfc31ddd">More...</a><br /></td></tr>
<tr class="separator:a6da36c8111d0b80228eb1560cfc31ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3d1dc8761358f14ab2aa168e1402d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a6c3d1dc8761358f14ab2aa168e1402d8">inherit</a> (std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt; gpu, REAL *data, len_t <a class="el" href="classunimat.html#ad4b4b6f0d9de498f8ba27afb237601ba">nrows</a>, len_t <a class="el" href="classunimat.html#abb62a12023f61a32c5503e00a9c028db">ncols</a>, bool free_on_destruct=false)</td></tr>
<tr class="memdesc:a6c3d1dc8761358f14ab2aa168e1402d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal object storage to the specified array.  <a href="#a6c3d1dc8761358f14ab2aa168e1402d8">More...</a><br /></td></tr>
<tr class="separator:a6c3d1dc8761358f14ab2aa168e1402d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32217080d10bed5a4e2eeabc23462afc"><td class="memItemLeft" align="right" valign="top"><a id="a32217080d10bed5a4e2eeabc23462afc"></a>
<a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a32217080d10bed5a4e2eeabc23462afc">dupe</a> () const</td></tr>
<tr class="memdesc:a32217080d10bed5a4e2eeabc23462afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the object in a deep copy. <br /></td></tr>
<tr class="separator:a32217080d10bed5a4e2eeabc23462afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18978fd278654d6598bc9c4a27441ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#ac18978fd278654d6598bc9c4a27441ab">print</a> (uint8_t ndigits=4, bool add_final_blank=true) const</td></tr>
<tr class="memdesc:ac18978fd278654d6598bc9c4a27441ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all values in the object.  <a href="#ac18978fd278654d6598bc9c4a27441ab">More...</a><br /></td></tr>
<tr class="separator:ac18978fd278654d6598bc9c4a27441ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c3989069718ea3ad8029f8286ec829"><td class="memItemLeft" align="right" valign="top"><a id="a86c3989069718ea3ad8029f8286ec829"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a86c3989069718ea3ad8029f8286ec829">info</a> () const</td></tr>
<tr class="memdesc:a86c3989069718ea3ad8029f8286ec829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some brief information about the object. <br /></td></tr>
<tr class="separator:a86c3989069718ea3ad8029f8286ec829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d975ab9a4b1ed975cde845dffcb2a1"><td class="memItemLeft" align="right" valign="top"><a id="a64d975ab9a4b1ed975cde845dffcb2a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a64d975ab9a4b1ed975cde845dffcb2a1">fill_zero</a> ()</td></tr>
<tr class="memdesc:a64d975ab9a4b1ed975cde845dffcb2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values to zero. <br /></td></tr>
<tr class="separator:a64d975ab9a4b1ed975cde845dffcb2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedb40624722fa214a887aeb399a3596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#aaedb40624722fa214a887aeb399a3596">fill_val</a> (const REAL v)</td></tr>
<tr class="memdesc:aaedb40624722fa214a887aeb399a3596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values to input value.  <a href="#aaedb40624722fa214a887aeb399a3596">More...</a><br /></td></tr>
<tr class="separator:aaedb40624722fa214a887aeb399a3596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284b43eb33e9b6327d5b9b8f9972fe07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a284b43eb33e9b6327d5b9b8f9972fe07">fill_linspace</a> (const REAL start, const REAL stop)</td></tr>
<tr class="memdesc:a284b43eb33e9b6327d5b9b8f9972fe07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values to linearly spaced numbers.  <a href="#a284b43eb33e9b6327d5b9b8f9972fe07">More...</a><br /></td></tr>
<tr class="separator:a284b43eb33e9b6327d5b9b8f9972fe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f5bc27649927b95608888389541bc0"><td class="memItemLeft" align="right" valign="top"><a id="af5f5bc27649927b95608888389541bc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#af5f5bc27649927b95608888389541bc0">fill_eye</a> ()</td></tr>
<tr class="memdesc:af5f5bc27649927b95608888389541bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0. <br /></td></tr>
<tr class="separator:af5f5bc27649927b95608888389541bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54488a6e7b1748245a0c2f89f58ab90a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a54488a6e7b1748245a0c2f89f58ab90a">fill_diag</a> (const <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a54488a6e7b1748245a0c2f89f58ab90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries of the matrix to those in the vector.  <a href="#a54488a6e7b1748245a0c2f89f58ab90a">More...</a><br /></td></tr>
<tr class="separator:a54488a6e7b1748245a0c2f89f58ab90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff84b6286b48f37a84e71b5504e05c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a5eff84b6286b48f37a84e71b5504e05c">fill_runif</a> (const uint32_t seed, const REAL min=0, const REAL max=1)</td></tr>
<tr class="memdesc:a5eff84b6286b48f37a84e71b5504e05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="#a5eff84b6286b48f37a84e71b5504e05c">More...</a><br /></td></tr>
<tr class="separator:a5eff84b6286b48f37a84e71b5504e05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b00c84ead854867b202c575b686a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a20b00c84ead854867b202c575b686a7a">fill_runif</a> (const REAL min=0, const REAL max=1)</td></tr>
<tr class="separator:a20b00c84ead854867b202c575b686a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be5781af71bda9e40afb68549a91ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#aa1be5781af71bda9e40afb68549a91ed">fill_rnorm</a> (const uint32_t seed, const REAL mean=0, const REAL sd=1)</td></tr>
<tr class="memdesc:aa1be5781af71bda9e40afb68549a91ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="#aa1be5781af71bda9e40afb68549a91ed">More...</a><br /></td></tr>
<tr class="separator:aa1be5781af71bda9e40afb68549a91ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c86ae63f0ba78972cfb2152bc30bbe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a6c86ae63f0ba78972cfb2152bc30bbe2">fill_rnorm</a> (const REAL mean=0, const REAL sd=1)</td></tr>
<tr class="separator:a6c86ae63f0ba78972cfb2152bc30bbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460e49f498fcd95eac7ca426ffebfe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a1460e49f498fcd95eac7ca426ffebfe6">diag</a> (<a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a1460e49f498fcd95eac7ca426ffebfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diagonal entries.  <a href="#a1460e49f498fcd95eac7ca426ffebfe6">More...</a><br /></td></tr>
<tr class="separator:a1460e49f498fcd95eac7ca426ffebfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f24f320ff6ba7e84eed821431dcaa4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a3f24f320ff6ba7e84eed821431dcaa4a">antidiag</a> (<a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a3f24f320ff6ba7e84eed821431dcaa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the anti-diagonal entries, i.e. those on the bottom-left to top-right.  <a href="#a3f24f320ff6ba7e84eed821431dcaa4a">More...</a><br /></td></tr>
<tr class="separator:a3f24f320ff6ba7e84eed821431dcaa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45e2688ca8d4e9323e639718ff773d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a5e45e2688ca8d4e9323e639718ff773d">scale</a> (const REAL s)</td></tr>
<tr class="memdesc:a5e45e2688ca8d4e9323e639718ff773d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all values by the input value.  <a href="#a5e45e2688ca8d4e9323e639718ff773d">More...</a><br /></td></tr>
<tr class="separator:a5e45e2688ca8d4e9323e639718ff773d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459ffdf00d680f9a3b7637e7b890f192"><td class="memItemLeft" align="right" valign="top"><a id="a459ffdf00d680f9a3b7637e7b890f192"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a459ffdf00d680f9a3b7637e7b890f192">rev_rows</a> ()</td></tr>
<tr class="memdesc:a459ffdf00d680f9a3b7637e7b890f192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the rows of the matrix. <br /></td></tr>
<tr class="separator:a459ffdf00d680f9a3b7637e7b890f192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92348c262b81b3ca718c11a1729c3e"><td class="memItemLeft" align="right" valign="top"><a id="a8a92348c262b81b3ca718c11a1729c3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a8a92348c262b81b3ca718c11a1729c3e">rev_cols</a> ()</td></tr>
<tr class="memdesc:a8a92348c262b81b3ca718c11a1729c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the columns of the matrix. <br /></td></tr>
<tr class="separator:a8a92348c262b81b3ca718c11a1729c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cd7d0f41db2dc0fe41fb8511472998"><td class="memItemLeft" align="right" valign="top"><a id="aa9cd7d0f41db2dc0fe41fb8511472998"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#aa9cd7d0f41db2dc0fe41fb8511472998">any_inf</a> () const</td></tr>
<tr class="memdesc:aa9cd7d0f41db2dc0fe41fb8511472998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are any values infinite? <br /></td></tr>
<tr class="separator:aa9cd7d0f41db2dc0fe41fb8511472998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a2d988aea078e2511a7be6660b917d"><td class="memItemLeft" align="right" valign="top"><a id="a37a2d988aea078e2511a7be6660b917d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>any_nan</b> () const</td></tr>
<tr class="separator:a37a2d988aea078e2511a7be6660b917d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6dfdc407121b32c51286116f0032d1"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#abc6dfdc407121b32c51286116f0032d1">get</a> (const len_t i) const</td></tr>
<tr class="memdesc:abc6dfdc407121b32c51286116f0032d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified value.  <a href="#abc6dfdc407121b32c51286116f0032d1">More...</a><br /></td></tr>
<tr class="separator:abc6dfdc407121b32c51286116f0032d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dff4705adcff28ddc9c18730bb0020"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a92dff4705adcff28ddc9c18730bb0020">get</a> (const len_t i, const len_t j) const</td></tr>
<tr class="memdesc:a92dff4705adcff28ddc9c18730bb0020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified value.  <a href="#a92dff4705adcff28ddc9c18730bb0020">More...</a><br /></td></tr>
<tr class="separator:a92dff4705adcff28ddc9c18730bb0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea663e1f94458582ac50ff37148eafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a6ea663e1f94458582ac50ff37148eafa">set</a> (const len_t i, const REAL v)</td></tr>
<tr class="memdesc:a6ea663e1f94458582ac50ff37148eafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage at the specified index with the provided value.  <a href="#a6ea663e1f94458582ac50ff37148eafa">More...</a><br /></td></tr>
<tr class="separator:a6ea663e1f94458582ac50ff37148eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbbbf787ce2e4a01f702801b5467cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a6cbbbf787ce2e4a01f702801b5467cc3">set</a> (const len_t i, const len_t j, const REAL v)</td></tr>
<tr class="memdesc:a6cbbbf787ce2e4a01f702801b5467cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage at the specified index with the provided value.  <a href="#a6cbbbf787ce2e4a01f702801b5467cc3">More...</a><br /></td></tr>
<tr class="separator:a6cbbbf787ce2e4a01f702801b5467cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace0fde33583f5686fb73e452a3a32bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#aace0fde33583f5686fb73e452a3a32bd">get_row</a> (const len_t i, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;v) const</td></tr>
<tr class="memdesc:aace0fde33583f5686fb73e452a3a32bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified row.  <a href="#aace0fde33583f5686fb73e452a3a32bd">More...</a><br /></td></tr>
<tr class="separator:aace0fde33583f5686fb73e452a3a32bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef878e2c6fa9c985b1f9c4cf5cdcbe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a5ef878e2c6fa9c985b1f9c4cf5cdcbe1">get_col</a> (const len_t j, <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;v) const</td></tr>
<tr class="memdesc:a5ef878e2c6fa9c985b1f9c4cf5cdcbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified column.  <a href="#a5ef878e2c6fa9c985b1f9c4cf5cdcbe1">More...</a><br /></td></tr>
<tr class="separator:a5ef878e2c6fa9c985b1f9c4cf5cdcbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1725a3695e34e5b442978abf4f5d71b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#af1725a3695e34e5b442978abf4f5d71b">operator==</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x) const</td></tr>
<tr class="memdesc:af1725a3695e34e5b442978abf4f5d71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the two objects are the same.  <a href="#af1725a3695e34e5b442978abf4f5d71b">More...</a><br /></td></tr>
<tr class="separator:af1725a3695e34e5b442978abf4f5d71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0548fecaf69b56ea8dada8857646bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a3b0548fecaf69b56ea8dada8857646bd">operator!=</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x) const</td></tr>
<tr class="memdesc:a3b0548fecaf69b56ea8dada8857646bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the two objects are not the same. Uses same internal logic as the <code>==</code> method.  <a href="#a3b0548fecaf69b56ea8dada8857646bd">More...</a><br /></td></tr>
<tr class="separator:a3b0548fecaf69b56ea8dada8857646bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7398543e36b3c11627746772d537be0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgpumat.html#a7398543e36b3c11627746772d537be0b">operator=</a> (const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a7398543e36b3c11627746772d537be0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator that sets the LHS to a shallow copy of the input. Desctruction of the LHS object will not result in the internal array storage being freed.  <a href="#a7398543e36b3c11627746772d537be0b">More...</a><br /></td></tr>
<tr class="separator:a7398543e36b3c11627746772d537be0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2905b012b0aaf6566ff43fda647f0dd6"><td class="memItemLeft" align="right" valign="top"><a id="a2905b012b0aaf6566ff43fda647f0dd6"></a>
std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_card</b> () const</td></tr>
<tr class="separator:a2905b012b0aaf6566ff43fda647f0dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3269ee4dc9f223ac132171369031f42"><td class="memItemLeft" align="right" valign="top"><a id="ae3269ee4dc9f223ac132171369031f42"></a>
dim3&#160;</td><td class="memItemRight" valign="bottom"><b>get_blockdim</b> () const</td></tr>
<tr class="separator:ae3269ee4dc9f223ac132171369031f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dccae7ab55bdeae7f0dca88115cbd9"><td class="memItemLeft" align="right" valign="top"><a id="a06dccae7ab55bdeae7f0dca88115cbd9"></a>
dim3&#160;</td><td class="memItemRight" valign="bottom"><b>get_griddim</b> () const</td></tr>
<tr class="separator:a06dccae7ab55bdeae7f0dca88115cbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classunimat"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classunimat')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classunimat.html">unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:aea7110434c7f6ec211135cfc6726d64a inherit pub_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="aea7110434c7f6ec211135cfc6726d64a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunimat.html#aea7110434c7f6ec211135cfc6726d64a">is_square</a> () const</td></tr>
<tr class="memdesc:aea7110434c7f6ec211135cfc6726d64a inherit pub_methods_classunimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the matrix square? <br /></td></tr>
<tr class="separator:aea7110434c7f6ec211135cfc6726d64a inherit pub_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b4b6f0d9de498f8ba27afb237601ba inherit pub_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="ad4b4b6f0d9de498f8ba27afb237601ba"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunimat.html#ad4b4b6f0d9de498f8ba27afb237601ba">nrows</a> () const</td></tr>
<tr class="memdesc:ad4b4b6f0d9de498f8ba27afb237601ba inherit pub_methods_classunimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br /></td></tr>
<tr class="separator:ad4b4b6f0d9de498f8ba27afb237601ba inherit pub_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb62a12023f61a32c5503e00a9c028db inherit pub_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="abb62a12023f61a32c5503e00a9c028db"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunimat.html#abb62a12023f61a32c5503e00a9c028db">ncols</a> () const</td></tr>
<tr class="memdesc:abb62a12023f61a32c5503e00a9c028db inherit pub_methods_classunimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br /></td></tr>
<tr class="separator:abb62a12023f61a32c5503e00a9c028db inherit pub_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5226d0eb31559f3e98aee8f31a933919 inherit pub_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a5226d0eb31559f3e98aee8f31a933919"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunimat.html#a5226d0eb31559f3e98aee8f31a933919">data_ptr</a> ()</td></tr>
<tr class="memdesc:a5226d0eb31559f3e98aee8f31a933919 inherit pub_methods_classunimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the internal array. <br /></td></tr>
<tr class="separator:a5226d0eb31559f3e98aee8f31a933919 inherit pub_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd35bf55a4288571854d1c905e2737c inherit pub_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="abfd35bf55a4288571854d1c905e2737c"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><b>data_ptr</b> () const</td></tr>
<tr class="separator:abfd35bf55a4288571854d1c905e2737c inherit pub_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a889508b632cadf6fc751e545816266a0"><td class="memItemLeft" align="right" valign="top"><a id="a889508b632cadf6fc751e545816266a0"></a>
std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>c</b></td></tr>
<tr class="separator:a889508b632cadf6fc751e545816266a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classunimat"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classunimat')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classunimat.html">unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a0dead5fe22bc62cf9a4ea08d3edb33d8 inherit pro_attribs_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a0dead5fe22bc62cf9a4ea08d3edb33d8"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a0dead5fe22bc62cf9a4ea08d3edb33d8 inherit pro_attribs_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5dd9e38b7cfb68833c91234452e3d9 inherit pro_attribs_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a0d5dd9e38b7cfb68833c91234452e3d9"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:a0d5dd9e38b7cfb68833c91234452e3d9 inherit pro_attribs_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aafa1aa30ef570342ba551fbf929335 inherit pro_attribs_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a0aafa1aa30ef570342ba551fbf929335"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a0aafa1aa30ef570342ba551fbf929335 inherit pro_attribs_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d87b020f139ea32c1fce7bc4ed99d36 inherit pro_attribs_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a8d87b020f139ea32c1fce7bc4ed99d36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>free_data</b></td></tr>
<tr class="separator:a8d87b020f139ea32c1fce7bc4ed99d36 inherit pro_attribs_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classunimat"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classunimat')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classunimat.html">unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:ae3b3fc33a090620664324f595c3dbeec inherit pro_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="ae3b3fc33a090620664324f595c3dbeec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>should_free</b> () const</td></tr>
<tr class="separator:ae3b3fc33a090620664324f595c3dbeec inherit pro_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a494453c374ecdb5772db2720378a inherit pro_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a707a494453c374ecdb5772db2720378a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_index</b> (const len_t i) const</td></tr>
<tr class="separator:a707a494453c374ecdb5772db2720378a inherit pro_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590b273c2040a2ee13fa7cc97085209b inherit pro_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a590b273c2040a2ee13fa7cc97085209b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_index</b> (const len_t i, const len_t j) const</td></tr>
<tr class="separator:a590b273c2040a2ee13fa7cc97085209b inherit pro_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b220d28caa653acb1e81fcf8e99efdd inherit pro_methods_classunimat"><td class="memItemLeft" align="right" valign="top"><a id="a7b220d28caa653acb1e81fcf8e99efdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printval</b> (const REAL val, uint8_t ndigits) const</td></tr>
<tr class="separator:a7b220d28caa653acb1e81fcf8e99efdd inherit pro_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7f849322f0360843e0650139e5545c inherit pro_methods_classunimat"><td class="memTemplParams" colspan="2"><a id="a4f7f849322f0360843e0650139e5545c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4f7f849322f0360843e0650139e5545c inherit pro_methods_classunimat"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>printval</b> (const int val, uint8_t ndigits) const</td></tr>
<tr class="separator:a4f7f849322f0360843e0650139e5545c inherit pro_methods_classunimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename REAL&gt;<br />
class gpumat&lt; REAL &gt;</h3>

<p>Matrix class for data held on a single GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be '__half', 'float', or 'double'. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6c77c422b5a4b82574d04688f2b1de5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c77c422b5a4b82574d04688f2b1de5d">&#9670;&nbsp;</a></span>gpumat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::<a class="el" href="classgpumat.html">gpumat</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td>
          <td class="paramname"><em>gpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object with no internal allocated storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu</td><td>Shared pointer to GPU card object.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> c = <a class="code" href="namespacegpuhelpers.html#af0db100c06edefae1a036c8f1d13b4dd">gpuhelpers::new_card</a>(0);</div><div class="line"><a class="code" href="classgpumat.html">gpumat&lt;float&gt;</a> x(c);</div></div><!-- fragment --> 
</div>
</div>
<a id="acd6a15bfcaaf9899cf384ba6f06484a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6a15bfcaaf9899cf384ba6f06484a8">&#9670;&nbsp;</a></span>gpumat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::<a class="el" href="classgpumat.html">gpumat</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td>
          <td class="paramname"><em>gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu</td><td>Shared pointer to GPU card object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the allocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> c = <a class="code" href="namespacegpuhelpers.html#af0db100c06edefae1a036c8f1d13b4dd">gpuhelpers::new_card</a>(0);</div><div class="line"><a class="code" href="classgpumat.html">gpumat&lt;float&gt;</a> x(c, 3, 2);</div></div><!-- fragment --> 
</div>
</div>
<a id="a7e70a7e554aae2073b31059364b6f2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e70a7e554aae2073b31059364b6f2b1">&#9670;&nbsp;</a></span>gpumat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::<a class="el" href="classgpumat.html">gpumat</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td>
          <td class="paramname"><em>gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL *&#160;</td>
          <td class="paramname"><em>data_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destruct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object with inherited data. Essentially the same as using the minimal constructor and immediately calling the <code><a class="el" href="classgpumat.html#a6c3d1dc8761358f14ab2aa168e1402d8" title="Set the internal object storage to the specified array. ">inherit()</a></code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu</td><td>Shared pointer to GPU card object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_</td><td>Storage array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the array, i.e. the length of the array is nrows*ncols. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_on_destruct</td><td>Should the inherited array <code>data_</code> be freed when the matrix object is destroyed?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f24f320ff6ba7e84eed821431dcaa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f24f320ff6ba7e84eed821431dcaa4a">&#9670;&nbsp;</a></span>antidiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::antidiag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the anti-diagonal entries, i.e. those on the bottom-left to top-right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The anti-diagonal. Length should match the length of the diagonal of the input (minimum of the matrix dimensions). If not, the vector will automatically be resized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a1460e49f498fcd95eac7ca426ffebfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460e49f498fcd95eac7ca426ffebfe6">&#9670;&nbsp;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the diagonal entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The diagonal. Length should match the length of the diagonal of the input (minimum of the matrix dimensions). If not, the vector will automatically be resized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a54488a6e7b1748245a0c2f89f58ab90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54488a6e7b1748245a0c2f89f58ab90a">&#9670;&nbsp;</a></span>fill_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries of the matrix to those in the vector. </p>
<p>If the vector is smaller than the matrix diagonal, the vector will recycle until the matrix diagonal is filled. If the vector is longer, then not all of it will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector of values to set the matrix diagonal to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a284b43eb33e9b6327d5b9b8f9972fe07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284b43eb33e9b6327d5b9b8f9972fe07">&#9670;&nbsp;</a></span>fill_linspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_linspace </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set values to linearly spaced numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start,stop</td><td>Beginning/ending numbers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1be5781af71bda9e40afb68549a91ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1be5781af71bda9e40afb68549a91ed">&#9670;&nbsp;</a></span>fill_rnorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_rnorm </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sd</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>Seed for the rng. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean,sd</td><td>Parameters for the generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Some internal GPU data has to be allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If something goes wrong with the GPU generator, a <code>runtime_error</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a6c86ae63f0ba78972cfb2152bc30bbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c86ae63f0ba78972cfb2152bc30bbe2">&#9670;&nbsp;</a></span>fill_rnorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_rnorm </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sd</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5eff84b6286b48f37a84e71b5504e05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff84b6286b48f37a84e71b5504e05c">&#9670;&nbsp;</a></span>fill_runif() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_runif </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>min</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>Seed for the rng. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min,max</td><td>Parameters for the generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Some internal GPU data has to be allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If something goes wrong with the GPU generator, a <code>runtime_error</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a20b00c84ead854867b202c575b686a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b00c84ead854867b202c575b686a7a">&#9670;&nbsp;</a></span>fill_runif() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_runif </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>min</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aaedb40624722fa214a887aeb399a3596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedb40624722fa214a887aeb399a3596">&#9670;&nbsp;</a></span>fill_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::fill_val </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values to input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value to set all data values to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc6dfdc407121b32c51286116f0032d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6dfdc407121b32c51286116f0032d1">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the desired value, 0-indexed. The numbering considers the internal storage as a 1-dimensional array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </dd></dl>

</div>
</div>
<a id="a92dff4705adcff28ddc9c18730bb0020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dff4705adcff28ddc9c18730bb0020">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i,j</td><td>The indices of the desired value, 0-indexed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </dd></dl>

</div>
</div>
<a id="a5ef878e2c6fa9c985b1f9c4cf5cdcbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef878e2c6fa9c985b1f9c4cf5cdcbe1">&#9670;&nbsp;</a></span>get_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::get_col </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The desired column, 0-indexed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The column values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If <code>j</code> is an inappropriate value (i.e. does not refer to a matrix column), then the method will throw a <code>logic_error</code> exception. If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="aace0fde33583f5686fb73e452a3a32bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace0fde33583f5686fb73e452a3a32bd">&#9670;&nbsp;</a></span>get_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgpuvec.html">gpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The desired row, 0-indexed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The row values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>If the output dimension is inappropriately sized, it will automatically be re-allocated.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If <code>i</code> is an inappropriate value (i.e. does not refer to a matrix row), then the method will throw a <code>logic_error</code> exception. If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a6c3d1dc8761358f14ab2aa168e1402d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3d1dc8761358f14ab2aa168e1402d8">&#9670;&nbsp;</a></span>inherit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::inherit </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td>
          <td class="paramname"><em>gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destruct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal object storage to the specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu</td><td>Shared pointer to GPU card object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Value storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the matrix. The product of these should be the length of the input <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_on_destruct</td><td>Should the object destructor free the internal array <code>data</code>?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a3b0548fecaf69b56ea8dada8857646bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0548fecaf69b56ea8dada8857646bd">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgpumat.html">gpumat</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the two objects are not the same. Uses same internal logic as the <code>==</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Comparison</td><td>object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7398543e36b3c11627746772d537be0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7398543e36b3c11627746772d537be0b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp; <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator that sets the LHS to a shallow copy of the input. Desctruction of the LHS object will not result in the internal array storage being freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Setter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1725a3695e34e5b442978abf4f5d71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1725a3695e34e5b442978abf4f5d71b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgpumat.html">gpumat</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the two objects are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Comparison</td><td>object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the dimensions mismatch, then <code>false</code> is necessarily returned. Next, if the card objects have different ordinal IDs, then <code>false</code> is returned. Next, if the pointer to the internal storage arrays match, then <code>true</code> is returned. Otherwise the objects are compared value by value. </dd></dl>

</div>
</div>
<a id="ac18978fd278654d6598bc9c4a27441ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18978fd278654d6598bc9c4a27441ab">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::print </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ndigits</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_final_blank</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print all values in the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of decimal digits to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_final_blank</td><td>Should a final blank line be printed? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad661c1de72bbee7b54b8196191f2c459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad661c1de72bbee7b54b8196191f2c459">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the internal object storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Resizing triggers a re-allocation.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the reallocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a6da36c8111d0b80228eb1560cfc31ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da36c8111d0b80228eb1560cfc31ddd">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcard.html">card</a> &gt;&#160;</td>
          <td class="paramname"><em>gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the internal object storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu</td><td>Shared pointer to GPU card object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Resizing triggers a re-allocation.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>If the reallocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown. </dd></dl>

</div>
</div>
<a id="a5e45e2688ca8d4e9323e639718ff773d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e45e2688ca8d4e9323e639718ff773d">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply all values by the input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Scaling value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ea663e1f94458582ac50ff37148eafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea663e1f94458582ac50ff37148eafa">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the storage at the specified index with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the desired value, 0-indexed. The numbering considers the internal storage as a 1-dimensional array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </dd></dl>

</div>
</div>
<a id="a6cbbbf787ce2e4a01f702801b5467cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbbbf787ce2e4a01f702801b5467cc3">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgpumat.html">gpumat</a>&lt; REAL &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the storage at the specified index with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i,j</td><td>The indices of the desired value, 0-indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>If indices are out of bounds, the method will throw a <code>runtime_error</code> exception. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/iao/sw/dev/fml/src/gpu/<a class="el" href="gpumat_8hh_source.html">gpumat.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classgpumat.html">gpumat</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
