<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fml: fml::mpimat&lt; REAL &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fml_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fml
   &#160;<span id="projectnumber">0.1-0</span>
   </div>
   <div id="projectbrief">Fused Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfml_1_1mpimat.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classfml_1_1mpimat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fml::mpimat&lt; REAL &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix class for data distributed over MPI in the 2-d block cyclic format.  
 <a href="classfml_1_1mpimat.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mpimat_8hh_source.html">mpimat.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fml::mpimat&lt; REAL &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfml_1_1mpimat.png" usemap="#fml::mpimat_3C_20REAL_20_3E_map" alt=""/>
  <map id="fml::mpimat_3C_20REAL_20_3E_map" name="fml::mpimat_3C_20REAL_20_3E_map">
<area href="classfml_1_1unimat.html" title="Base matrix class. Not meant for direct use. Instead see cpumat, gpumat, and mpimat." alt="fml::unimat&lt; REAL &gt;" shape="rect" coords="0,0,128,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67abbd85f51a287c33c72b903f15207b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a67abbd85f51a287c33c72b903f15207b">mpimat</a> (const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;blacs_grid)</td></tr>
<tr class="memdesc:a67abbd85f51a287c33c72b903f15207b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object with no internal allocated storage.  <a href="classfml_1_1mpimat.html#a67abbd85f51a287c33c72b903f15207b">More...</a><br /></td></tr>
<tr class="separator:a67abbd85f51a287c33c72b903f15207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27708de567dffa86feb9d88ed79b15db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a27708de567dffa86feb9d88ed79b15db">mpimat</a> (const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;blacs_grid, int bf_rows, int bf_cols)</td></tr>
<tr class="memdesc:a27708de567dffa86feb9d88ed79b15db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object.  <a href="classfml_1_1mpimat.html#a27708de567dffa86feb9d88ed79b15db">More...</a><br /></td></tr>
<tr class="separator:a27708de567dffa86feb9d88ed79b15db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0edf417fc437ca69e6cac990c9f81f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#ad0edf417fc437ca69e6cac990c9f81f1">mpimat</a> (const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;blacs_grid, len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>, int bf_rows, int bf_cols)</td></tr>
<tr class="memdesc:ad0edf417fc437ca69e6cac990c9f81f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object.  <a href="classfml_1_1mpimat.html#ad0edf417fc437ca69e6cac990c9f81f1">More...</a><br /></td></tr>
<tr class="separator:ad0edf417fc437ca69e6cac990c9f81f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5acfea5e45932e97c7703ce767da447"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#af5acfea5e45932e97c7703ce767da447">mpimat</a> (const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;blacs_grid, REAL *data_, len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>, int bf_rows, int bf_cols, bool free_on_destruct=false)</td></tr>
<tr class="memdesc:af5acfea5e45932e97c7703ce767da447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matrix object with inherited data. Essentially the same as using the minimal constructor and immediately calling the <code><a class="el" href="classfml_1_1mpimat.html#ac5045c7d3304e692ae476ea2189fb6e9" title="Set the internal object storage to the specified array.">inherit()</a></code> method.  <a href="classfml_1_1mpimat.html#af5acfea5e45932e97c7703ce767da447">More...</a><br /></td></tr>
<tr class="separator:af5acfea5e45932e97c7703ce767da447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf667066230494d02d9556e1326a2028"><td class="memItemLeft" align="right" valign="top"><a id="adf667066230494d02d9556e1326a2028"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mpimat</b> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a> &amp;x)</td></tr>
<tr class="separator:adf667066230494d02d9556e1326a2028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7185d9e8efe8cad812e9a7722d654b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a7185d9e8efe8cad812e9a7722d654b79">resize</a> (len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>)</td></tr>
<tr class="memdesc:a7185d9e8efe8cad812e9a7722d654b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the internal object storage.  <a href="classfml_1_1mpimat.html#a7185d9e8efe8cad812e9a7722d654b79">More...</a><br /></td></tr>
<tr class="separator:a7185d9e8efe8cad812e9a7722d654b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1e030381f04d7ea0f82b8561a894f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a7c1e030381f04d7ea0f82b8561a894f3">resize</a> (len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>, int bf_rows, int bf_cols)</td></tr>
<tr class="memdesc:a7c1e030381f04d7ea0f82b8561a894f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the internal object storage.  <a href="classfml_1_1mpimat.html#a7c1e030381f04d7ea0f82b8561a894f3">More...</a><br /></td></tr>
<tr class="separator:a7c1e030381f04d7ea0f82b8561a894f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5045c7d3304e692ae476ea2189fb6e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#ac5045c7d3304e692ae476ea2189fb6e9">inherit</a> (<a class="el" href="classfml_1_1grid.html">grid</a> &amp;blacs_grid, REAL *data_, len_t <a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a>, len_t <a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a>, int bf_rows, int bf_cols, bool free_on_destruct=false)</td></tr>
<tr class="memdesc:ac5045c7d3304e692ae476ea2189fb6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal object storage to the specified array.  <a href="classfml_1_1mpimat.html#ac5045c7d3304e692ae476ea2189fb6e9">More...</a><br /></td></tr>
<tr class="separator:ac5045c7d3304e692ae476ea2189fb6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7915f4897521c9ff6f1d25af5400ee"><td class="memItemLeft" align="right" valign="top"><a id="aaa7915f4897521c9ff6f1d25af5400ee"></a>
<a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#aaa7915f4897521c9ff6f1d25af5400ee">dupe</a> () const</td></tr>
<tr class="memdesc:aaa7915f4897521c9ff6f1d25af5400ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the object in a deep copy. <br /></td></tr>
<tr class="separator:aaa7915f4897521c9ff6f1d25af5400ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028224f51f9fe269bb63182ad4d69282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a028224f51f9fe269bb63182ad4d69282">print</a> (uint8_t ndigits=4, bool add_final_blank=true) const</td></tr>
<tr class="memdesc:a028224f51f9fe269bb63182ad4d69282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all values in the object.  <a href="classfml_1_1mpimat.html#a028224f51f9fe269bb63182ad4d69282">More...</a><br /></td></tr>
<tr class="separator:a028224f51f9fe269bb63182ad4d69282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18538d123de5c26f7278f343459cff84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a18538d123de5c26f7278f343459cff84">info</a> () const</td></tr>
<tr class="memdesc:a18538d123de5c26f7278f343459cff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some brief information about the object.  <a href="classfml_1_1mpimat.html#a18538d123de5c26f7278f343459cff84">More...</a><br /></td></tr>
<tr class="separator:a18538d123de5c26f7278f343459cff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a30aeae3b5f58248adbdd7ff0faf7a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a9a30aeae3b5f58248adbdd7ff0faf7a4">fill_zero</a> ()</td></tr>
<tr class="memdesc:a9a30aeae3b5f58248adbdd7ff0faf7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values to zero.  <a href="classfml_1_1mpimat.html#a9a30aeae3b5f58248adbdd7ff0faf7a4">More...</a><br /></td></tr>
<tr class="separator:a9a30aeae3b5f58248adbdd7ff0faf7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718476cde182c47938541abc5970a650"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a718476cde182c47938541abc5970a650">fill_val</a> (const REAL v)</td></tr>
<tr class="memdesc:a718476cde182c47938541abc5970a650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values to input value.  <a href="classfml_1_1mpimat.html#a718476cde182c47938541abc5970a650">More...</a><br /></td></tr>
<tr class="separator:a718476cde182c47938541abc5970a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd4bc94d6ead162b09cdf718a6add3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#aacfd4bc94d6ead162b09cdf718a6add3">fill_linspace</a> ()</td></tr>
<tr class="memdesc:aacfd4bc94d6ead162b09cdf718a6add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values to linearly spaced numbers.  <a href="classfml_1_1mpimat.html#aacfd4bc94d6ead162b09cdf718a6add3">More...</a><br /></td></tr>
<tr class="separator:aacfd4bc94d6ead162b09cdf718a6add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa830bf0f86e7e2b4977e533cc00924bc"><td class="memItemLeft" align="right" valign="top"><a id="aa830bf0f86e7e2b4977e533cc00924bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_linspace</b> (const REAL start, const REAL stop)</td></tr>
<tr class="separator:aa830bf0f86e7e2b4977e533cc00924bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfde7981b4807a15e460e1c43b0100a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a0dfde7981b4807a15e460e1c43b0100a">fill_eye</a> ()</td></tr>
<tr class="memdesc:a0dfde7981b4807a15e460e1c43b0100a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="classfml_1_1mpimat.html#a0dfde7981b4807a15e460e1c43b0100a">More...</a><br /></td></tr>
<tr class="separator:a0dfde7981b4807a15e460e1c43b0100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4737065d99dd41befc7027ab95a7e51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a4737065d99dd41befc7027ab95a7e51a">fill_diag</a> (const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a4737065d99dd41befc7027ab95a7e51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries of the matrix to those in the vector.  <a href="classfml_1_1mpimat.html#a4737065d99dd41befc7027ab95a7e51a">More...</a><br /></td></tr>
<tr class="separator:a4737065d99dd41befc7027ab95a7e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ed76dc3cbefb7f29b5e231dce4bbdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#ad8ed76dc3cbefb7f29b5e231dce4bbdb">fill_runif</a> (const uint32_t seed, const REAL min=0, const REAL max=1)</td></tr>
<tr class="memdesc:ad8ed76dc3cbefb7f29b5e231dce4bbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="classfml_1_1mpimat.html#ad8ed76dc3cbefb7f29b5e231dce4bbdb">More...</a><br /></td></tr>
<tr class="separator:ad8ed76dc3cbefb7f29b5e231dce4bbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c15deab01ed4e89f2d830bea6a221b6"><td class="memItemLeft" align="right" valign="top"><a id="a1c15deab01ed4e89f2d830bea6a221b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a1c15deab01ed4e89f2d830bea6a221b6">fill_runif</a> (const REAL min=0, const REAL max=1)</td></tr>
<tr class="memdesc:a1c15deab01ed4e89f2d830bea6a221b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a1c15deab01ed4e89f2d830bea6a221b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53fdd4fffc54ec38ded4882104f47f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#aa53fdd4fffc54ec38ded4882104f47f3">fill_rnorm</a> (const uint32_t seed, const REAL mean=0, const REAL sd=1)</td></tr>
<tr class="memdesc:aa53fdd4fffc54ec38ded4882104f47f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diagonal entries to 1 and non-diagonal entries to 0.  <a href="classfml_1_1mpimat.html#aa53fdd4fffc54ec38ded4882104f47f3">More...</a><br /></td></tr>
<tr class="separator:aa53fdd4fffc54ec38ded4882104f47f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c382785d572f117f4c566a31001bf5"><td class="memItemLeft" align="right" valign="top"><a id="aa8c382785d572f117f4c566a31001bf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#aa8c382785d572f117f4c566a31001bf5">fill_rnorm</a> (const REAL mean=0, const REAL sd=1)</td></tr>
<tr class="memdesc:aa8c382785d572f117f4c566a31001bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aa8c382785d572f117f4c566a31001bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a46bc3dea06d2d6390c3c67919fa61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a21a46bc3dea06d2d6390c3c67919fa61">diag</a> (<a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a21a46bc3dea06d2d6390c3c67919fa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diagonal entries.  <a href="classfml_1_1mpimat.html#a21a46bc3dea06d2d6390c3c67919fa61">More...</a><br /></td></tr>
<tr class="separator:a21a46bc3dea06d2d6390c3c67919fa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877bf474060c79cdf1b4d444f48fc162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a877bf474060c79cdf1b4d444f48fc162">antidiag</a> (<a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a877bf474060c79cdf1b4d444f48fc162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the anti-diagonal entries, i.e. those on the bottom-left to top-right.  <a href="classfml_1_1mpimat.html#a877bf474060c79cdf1b4d444f48fc162">More...</a><br /></td></tr>
<tr class="separator:a877bf474060c79cdf1b4d444f48fc162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad636a7172741c2ed90471a4f98532742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#ad636a7172741c2ed90471a4f98532742">scale</a> (const REAL s)</td></tr>
<tr class="memdesc:ad636a7172741c2ed90471a4f98532742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all values by the input value.  <a href="classfml_1_1mpimat.html#ad636a7172741c2ed90471a4f98532742">More...</a><br /></td></tr>
<tr class="separator:ad636a7172741c2ed90471a4f98532742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7360c3d86d858bfc50447dd0ea4f171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#aa7360c3d86d858bfc50447dd0ea4f171">rev_rows</a> ()</td></tr>
<tr class="memdesc:aa7360c3d86d858bfc50447dd0ea4f171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the rows of the matrix.  <a href="classfml_1_1mpimat.html#aa7360c3d86d858bfc50447dd0ea4f171">More...</a><br /></td></tr>
<tr class="separator:aa7360c3d86d858bfc50447dd0ea4f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ee3cc25e640c844e71b8ee2176927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a566ee3cc25e640c844e71b8ee2176927">rev_cols</a> ()</td></tr>
<tr class="memdesc:a566ee3cc25e640c844e71b8ee2176927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the columns of the matrix.  <a href="classfml_1_1mpimat.html#a566ee3cc25e640c844e71b8ee2176927">More...</a><br /></td></tr>
<tr class="separator:a566ee3cc25e640c844e71b8ee2176927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c9ed7ea44163270cc040df7dc2766c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a69c9ed7ea44163270cc040df7dc2766c">any_inf</a> () const</td></tr>
<tr class="memdesc:a69c9ed7ea44163270cc040df7dc2766c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are any values infinite?  <a href="classfml_1_1mpimat.html#a69c9ed7ea44163270cc040df7dc2766c">More...</a><br /></td></tr>
<tr class="separator:a69c9ed7ea44163270cc040df7dc2766c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae866ab416eb67e522a4ffef6fd4acaeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#ae866ab416eb67e522a4ffef6fd4acaeb">any_nan</a> () const</td></tr>
<tr class="memdesc:ae866ab416eb67e522a4ffef6fd4acaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are any values NaN?  <a href="classfml_1_1mpimat.html#ae866ab416eb67e522a4ffef6fd4acaeb">More...</a><br /></td></tr>
<tr class="separator:ae866ab416eb67e522a4ffef6fd4acaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf093ad96ed3b00dc549bdf45e873dd"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a8cf093ad96ed3b00dc549bdf45e873dd">get</a> (const len_t i) const</td></tr>
<tr class="memdesc:a8cf093ad96ed3b00dc549bdf45e873dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified value.  <a href="classfml_1_1mpimat.html#a8cf093ad96ed3b00dc549bdf45e873dd">More...</a><br /></td></tr>
<tr class="separator:a8cf093ad96ed3b00dc549bdf45e873dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c4b62f9ad2de99929bd75fe040e971"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a83c4b62f9ad2de99929bd75fe040e971">get</a> (const len_t i, const len_t j) const</td></tr>
<tr class="memdesc:a83c4b62f9ad2de99929bd75fe040e971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified value.  <a href="classfml_1_1mpimat.html#a83c4b62f9ad2de99929bd75fe040e971">More...</a><br /></td></tr>
<tr class="separator:a83c4b62f9ad2de99929bd75fe040e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7c577c61e5ab6907dfb31cf493ddfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a4e7c577c61e5ab6907dfb31cf493ddfe">set</a> (const len_t i, const REAL v)</td></tr>
<tr class="memdesc:a4e7c577c61e5ab6907dfb31cf493ddfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage at the specified index with the provided value.  <a href="classfml_1_1mpimat.html#a4e7c577c61e5ab6907dfb31cf493ddfe">More...</a><br /></td></tr>
<tr class="separator:a4e7c577c61e5ab6907dfb31cf493ddfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098909a214f5cdcc5a71c8268895047c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a098909a214f5cdcc5a71c8268895047c">set</a> (const len_t i, const len_t j, const REAL v)</td></tr>
<tr class="memdesc:a098909a214f5cdcc5a71c8268895047c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage at the specified index with the provided value.  <a href="classfml_1_1mpimat.html#a098909a214f5cdcc5a71c8268895047c">More...</a><br /></td></tr>
<tr class="separator:a098909a214f5cdcc5a71c8268895047c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18fdd686b71048cfae11d0ee2a678fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#ad18fdd686b71048cfae11d0ee2a678fb">get_row</a> (const len_t i, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v) const</td></tr>
<tr class="memdesc:ad18fdd686b71048cfae11d0ee2a678fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified row.  <a href="classfml_1_1mpimat.html#ad18fdd686b71048cfae11d0ee2a678fb">More...</a><br /></td></tr>
<tr class="separator:ad18fdd686b71048cfae11d0ee2a678fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2066c04e3974602ba452b1ae42bf36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a6e2066c04e3974602ba452b1ae42bf36">set_row</a> (const len_t i, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:a6e2066c04e3974602ba452b1ae42bf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specified row.  <a href="classfml_1_1mpimat.html#a6e2066c04e3974602ba452b1ae42bf36">More...</a><br /></td></tr>
<tr class="separator:a6e2066c04e3974602ba452b1ae42bf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc07ece006268f5c81c7d991b3aa0b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#accc07ece006268f5c81c7d991b3aa0b2">get_col</a> (const len_t j, <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v) const</td></tr>
<tr class="memdesc:accc07ece006268f5c81c7d991b3aa0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified column.  <a href="classfml_1_1mpimat.html#accc07ece006268f5c81c7d991b3aa0b2">More...</a><br /></td></tr>
<tr class="separator:accc07ece006268f5c81c7d991b3aa0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77fefa817a7d4812c96a9ad680534d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#af77fefa817a7d4812c96a9ad680534d3">set_col</a> (const len_t j, const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;v)</td></tr>
<tr class="memdesc:af77fefa817a7d4812c96a9ad680534d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specified column.  <a href="classfml_1_1mpimat.html#af77fefa817a7d4812c96a9ad680534d3">More...</a><br /></td></tr>
<tr class="separator:af77fefa817a7d4812c96a9ad680534d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fe8d63ee7e3e82ee9d4b6c182452f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a65fe8d63ee7e3e82ee9d4b6c182452f3">operator==</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x) const</td></tr>
<tr class="memdesc:a65fe8d63ee7e3e82ee9d4b6c182452f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the two objects are the same.  <a href="classfml_1_1mpimat.html#a65fe8d63ee7e3e82ee9d4b6c182452f3">More...</a><br /></td></tr>
<tr class="separator:a65fe8d63ee7e3e82ee9d4b6c182452f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4ab57e8e3ad0b7e8cdf147582c39d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#abf4ab57e8e3ad0b7e8cdf147582c39d0">operator!=</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x) const</td></tr>
<tr class="memdesc:abf4ab57e8e3ad0b7e8cdf147582c39d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the two objects are not the same. Uses same internal logic as the <code>==</code> method.  <a href="classfml_1_1mpimat.html#abf4ab57e8e3ad0b7e8cdf147582c39d0">More...</a><br /></td></tr>
<tr class="separator:abf4ab57e8e3ad0b7e8cdf147582c39d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705bca92369247fce9b62d633a16dfcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1mpimat.html#a705bca92369247fce9b62d633a16dfcc">operator=</a> (const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;x)</td></tr>
<tr class="memdesc:a705bca92369247fce9b62d633a16dfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator that sets the LHS to a shallow copy of the input. Desctruction of the LHS object will not result in the internal array storage being freed.  <a href="classfml_1_1mpimat.html#a705bca92369247fce9b62d633a16dfcc">More...</a><br /></td></tr>
<tr class="separator:a705bca92369247fce9b62d633a16dfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb908a5f57cacf0a16907ebc258e0b0"><td class="memItemLeft" align="right" valign="top"><a id="a6cb908a5f57cacf0a16907ebc258e0b0"></a>
len_local_t&#160;</td><td class="memItemRight" valign="bottom"><b>nrows_local</b> () const</td></tr>
<tr class="separator:a6cb908a5f57cacf0a16907ebc258e0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738ad453dd8ecb366ec182ca04f54dfb"><td class="memItemLeft" align="right" valign="top"><a id="a738ad453dd8ecb366ec182ca04f54dfb"></a>
len_local_t&#160;</td><td class="memItemRight" valign="bottom"><b>ncols_local</b> () const</td></tr>
<tr class="separator:a738ad453dd8ecb366ec182ca04f54dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac79c6d20c71ef5b397f8ce7fd57835"><td class="memItemLeft" align="right" valign="top"><a id="a1ac79c6d20c71ef5b397f8ce7fd57835"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bf_rows</b> () const</td></tr>
<tr class="separator:a1ac79c6d20c71ef5b397f8ce7fd57835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ff7f7781edf95ef70fe0b5f6deef2a"><td class="memItemLeft" align="right" valign="top"><a id="a77ff7f7781edf95ef70fe0b5f6deef2a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bf_cols</b> () const</td></tr>
<tr class="separator:a77ff7f7781edf95ef70fe0b5f6deef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad27fe2accebd773f2d036e6ce20dad"><td class="memItemLeft" align="right" valign="top"><a id="a5ad27fe2accebd773f2d036e6ce20dad"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>desc_ptr</b> ()</td></tr>
<tr class="separator:a5ad27fe2accebd773f2d036e6ce20dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae0fed0cf7e87af6d7bfd56a658b3fd"><td class="memItemLeft" align="right" valign="top"><a id="a5ae0fed0cf7e87af6d7bfd56a658b3fd"></a>
const int *&#160;</td><td class="memItemRight" valign="bottom"><b>desc_ptr</b> () const</td></tr>
<tr class="separator:a5ae0fed0cf7e87af6d7bfd56a658b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784ccee9435acedc957f4f877c1c832d"><td class="memItemLeft" align="right" valign="top"><a id="a784ccee9435acedc957f4f877c1c832d"></a>
const <a class="el" href="classfml_1_1grid.html">grid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_grid</b> () const</td></tr>
<tr class="separator:a784ccee9435acedc957f4f877c1c832d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa034a882df95576f9c831838ecab54b"><td class="memItemLeft" align="right" valign="top"><a id="afa034a882df95576f9c831838ecab54b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_linspace</b> (const int start, const int stop)</td></tr>
<tr class="separator:afa034a882df95576f9c831838ecab54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classfml_1_1unimat"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classfml_1_1unimat')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classfml_1_1unimat.html">fml::unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a284ad0870284f7a8542c4f0974d33979 inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a284ad0870284f7a8542c4f0974d33979"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a284ad0870284f7a8542c4f0974d33979">is_square</a> () const</td></tr>
<tr class="memdesc:a284ad0870284f7a8542c4f0974d33979 inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the matrix square? <br /></td></tr>
<tr class="separator:a284ad0870284f7a8542c4f0974d33979 inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b70212a4383826986be87aad3b8908e inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a5b70212a4383826986be87aad3b8908e"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a5b70212a4383826986be87aad3b8908e">nrows</a> () const</td></tr>
<tr class="memdesc:a5b70212a4383826986be87aad3b8908e inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br /></td></tr>
<tr class="separator:a5b70212a4383826986be87aad3b8908e inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184e02405d68317c536b81e4a512bf4 inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a6184e02405d68317c536b81e4a512bf4"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a6184e02405d68317c536b81e4a512bf4">ncols</a> () const</td></tr>
<tr class="memdesc:a6184e02405d68317c536b81e4a512bf4 inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br /></td></tr>
<tr class="separator:a6184e02405d68317c536b81e4a512bf4 inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d05f3e788f0597dfc362f1090c002b inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a38d05f3e788f0597dfc362f1090c002b"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfml_1_1unimat.html#a38d05f3e788f0597dfc362f1090c002b">data_ptr</a> ()</td></tr>
<tr class="memdesc:a38d05f3e788f0597dfc362f1090c002b inherit pub_methods_classfml_1_1unimat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the internal array. <br /></td></tr>
<tr class="separator:a38d05f3e788f0597dfc362f1090c002b inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae453388ec85006b432addc857a7376b8 inherit pub_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ae453388ec85006b432addc857a7376b8"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><b>data_ptr</b> () const</td></tr>
<tr class="separator:ae453388ec85006b432addc857a7376b8 inherit pub_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acec4658ce65687c7b7a31578c6ea57fb"><td class="memItemLeft" align="right" valign="top"><a id="acec4658ce65687c7b7a31578c6ea57fb"></a>
len_local_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_local</b></td></tr>
<tr class="separator:acec4658ce65687c7b7a31578c6ea57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c841e1c35f1a916a315c374baf6d206"><td class="memItemLeft" align="right" valign="top"><a id="a3c841e1c35f1a916a315c374baf6d206"></a>
len_local_t&#160;</td><td class="memItemRight" valign="bottom"><b>n_local</b></td></tr>
<tr class="separator:a3c841e1c35f1a916a315c374baf6d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e679772660295cde14ac1456279e04b"><td class="memItemLeft" align="right" valign="top"><a id="a1e679772660295cde14ac1456279e04b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mb</b></td></tr>
<tr class="separator:a1e679772660295cde14ac1456279e04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75078fa8c9cea8bbfa016cefc5932bc0"><td class="memItemLeft" align="right" valign="top"><a id="a75078fa8c9cea8bbfa016cefc5932bc0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nb</b></td></tr>
<tr class="separator:a75078fa8c9cea8bbfa016cefc5932bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dae5b69fda51ca1def6917b0e904b2"><td class="memItemLeft" align="right" valign="top"><a id="ae6dae5b69fda51ca1def6917b0e904b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>desc</b> [9]</td></tr>
<tr class="separator:ae6dae5b69fda51ca1def6917b0e904b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bb9b894a25ec934f626e4ebf2d4eba"><td class="memItemLeft" align="right" valign="top"><a id="a88bb9b894a25ec934f626e4ebf2d4eba"></a>
<a class="el" href="classfml_1_1grid.html">grid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g</b></td></tr>
<tr class="separator:a88bb9b894a25ec934f626e4ebf2d4eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classfml_1_1unimat"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classfml_1_1unimat')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classfml_1_1unimat.html">fml::unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a5231e4efcaf932db382cde7506025825 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a5231e4efcaf932db382cde7506025825"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a5231e4efcaf932db382cde7506025825 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd837691fa367593668036257f2ea7 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ac0cd837691fa367593668036257f2ea7"></a>
len_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:ac0cd837691fa367593668036257f2ea7 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66baf83543ab8d784aa8d52cb198ba93 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a66baf83543ab8d784aa8d52cb198ba93"></a>
REAL *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a66baf83543ab8d784aa8d52cb198ba93 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04cf20d1d3c2bac8a855fe52ae8a9b3 inherit pro_attribs_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ac04cf20d1d3c2bac8a855fe52ae8a9b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>free_data</b></td></tr>
<tr class="separator:ac04cf20d1d3c2bac8a855fe52ae8a9b3 inherit pro_attribs_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classfml_1_1unimat"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classfml_1_1unimat')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classfml_1_1unimat.html">fml::unimat&lt; REAL &gt;</a></td></tr>
<tr class="memitem:a36e47630447174d37eca514f6db1d15d inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a36e47630447174d37eca514f6db1d15d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>should_free</b> () const</td></tr>
<tr class="separator:a36e47630447174d37eca514f6db1d15d inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a19947e5e9e6da1ef95b50933a2ea9 inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="ab0a19947e5e9e6da1ef95b50933a2ea9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_index</b> (const len_t i) const</td></tr>
<tr class="separator:ab0a19947e5e9e6da1ef95b50933a2ea9 inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef9b60c6468e711a17eaaf23235e5b6 inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a4ef9b60c6468e711a17eaaf23235e5b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_index</b> (const len_t i, const len_t j) const</td></tr>
<tr class="separator:a4ef9b60c6468e711a17eaaf23235e5b6 inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee5c5122090ab3615cb769ea453be2f inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a2ee5c5122090ab3615cb769ea453be2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printval</b> (const REAL val, uint8_t ndigits) const</td></tr>
<tr class="separator:a2ee5c5122090ab3615cb769ea453be2f inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6691e20c10b9b9c2705bdce6ef3cdeeb inherit pro_methods_classfml_1_1unimat"><td class="memItemLeft" align="right" valign="top"><a id="a6691e20c10b9b9c2705bdce6ef3cdeeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printval</b> (const int val, uint8_t ndigits) const</td></tr>
<tr class="separator:a6691e20c10b9b9c2705bdce6ef3cdeeb inherit pro_methods_classfml_1_1unimat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename REAL&gt;<br />
class fml::mpimat&lt; REAL &gt;</h3>

<p>Matrix class for data distributed over MPI in the 2-d block cyclic format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL</td><td>should be 'float' or 'double'. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67abbd85f51a287c33c72b903f15207b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67abbd85f51a287c33c72b903f15207b">&#9670;&nbsp;</a></span>mpimat() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1mpimat.html">mpimat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;&#160;</td>
          <td class="paramname"><em>blacs_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object with no internal allocated storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blacs_grid</td><td>Scalapack grid object.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication.</p>
<div class="fragment"><div class="line">grid g = grid(<a class="code" href="group___enumerations.html#ggaf4b9b0520217d168c1c074127e37f483a6256d0af0626d3f43493ed101b1e8576">PROC_GRID_SQUARE</a>);</div>
<div class="line">mpimat&lt;float&gt; x(g);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a27708de567dffa86feb9d88ed79b15db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27708de567dffa86feb9d88ed79b15db">&#9670;&nbsp;</a></span>mpimat() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1mpimat.html">mpimat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;&#160;</td>
          <td class="paramname"><em>blacs_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blacs_grid</td><td>Scalapack grid object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bf_rows,bf_cols</td><td>Row/column blocking factor.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the allocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method has no communication.</p>
<div class="fragment"><div class="line">grid g = grid(<a class="code" href="group___enumerations.html#ggaf4b9b0520217d168c1c074127e37f483a6256d0af0626d3f43493ed101b1e8576">PROC_GRID_SQUARE</a>);</div>
<div class="line">mpimat&lt;float&gt; x(g, 1, 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad0edf417fc437ca69e6cac990c9f81f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0edf417fc437ca69e6cac990c9f81f1">&#9670;&nbsp;</a></span>mpimat() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1mpimat.html">mpimat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;&#160;</td>
          <td class="paramname"><em>blacs_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blacs_grid</td><td>Scalapack grid object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the array, i.e. the length of the array is nrows*ncols. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bf_rows,bf_cols</td><td>Row/column blocking factor.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method has no communication.</p>
<div class="fragment"><div class="line">grid g = grid(<a class="code" href="group___enumerations.html#ggaf4b9b0520217d168c1c074127e37f483a6256d0af0626d3f43493ed101b1e8576">PROC_GRID_SQUARE</a>);</div>
<div class="line">mpimat&lt;float&gt; x(g, 3, 2, 1, 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af5acfea5e45932e97c7703ce767da447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5acfea5e45932e97c7703ce767da447">&#9670;&nbsp;</a></span>mpimat() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::<a class="el" href="classfml_1_1mpimat.html">mpimat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1grid.html">grid</a> &amp;&#160;</td>
          <td class="paramname"><em>blacs_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL *&#160;</td>
          <td class="paramname"><em>data_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destruct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct matrix object with inherited data. Essentially the same as using the minimal constructor and immediately calling the <code><a class="el" href="classfml_1_1mpimat.html#ac5045c7d3304e692ae476ea2189fb6e9" title="Set the internal object storage to the specified array.">inherit()</a></code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blacs_grid</td><td>Scalapack grid object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_</td><td>Storage array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the array, i.e. the length of the array is nrows*ncols. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bf_rows,bf_cols</td><td>Row/column blocking factor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_on_destruct</td><td>Should the inherited array <code>data_</code> be freed when the matrix object is destroyed?</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a877bf474060c79cdf1b4d444f48fc162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877bf474060c79cdf1b4d444f48fc162">&#9670;&nbsp;</a></span>antidiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::antidiag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">fml::cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the anti-diagonal entries, i.e. those on the bottom-left to top-right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The anti-diagonal. Length should match the length of the diagonal of the input (minimum of the matrix dimensions). If not, the vector will automatically be resized.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a69c9ed7ea44163270cc040df7dc2766c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c9ed7ea44163270cc040df7dc2766c">&#9670;&nbsp;</a></span>any_inf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::any_inf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Are any values infinite? </p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="ae866ab416eb67e522a4ffef6fd4acaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae866ab416eb67e522a4ffef6fd4acaeb">&#9670;&nbsp;</a></span>any_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::any_nan</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Are any values NaN? </p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a21a46bc3dea06d2d6390c3c67919fa61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a46bc3dea06d2d6390c3c67919fa61">&#9670;&nbsp;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">fml::cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the diagonal entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The diagonal. Length should match the length of the diagonal of the input (minimum of the matrix dimensions). If not, the vector will automatically be resized.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a4737065d99dd41befc7027ab95a7e51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4737065d99dd41befc7027ab95a7e51a">&#9670;&nbsp;</a></span>fill_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::fill_diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries of the matrix to those in the vector. </p>
<p>If the vector is smaller than the matrix diagonal, the vector will recycle until the matrix diagonal is filled. If the vector is longer, then not all of it will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector of values to set the matrix diagonal to.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a0dfde7981b4807a15e460e1c43b0100a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfde7981b4807a15e460e1c43b0100a">&#9670;&nbsp;</a></span>fill_eye()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::fill_eye</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="aacfd4bc94d6ead162b09cdf718a6add3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfd4bc94d6ead162b09cdf718a6add3">&#9670;&nbsp;</a></span>fill_linspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; T &gt;::fill_linspace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set values to linearly spaced numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start,stop</td><td>Beginning/ending numbers. If not supplied, the matrix will be filled with whole numbers from 1 to the total number of elements.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="aa53fdd4fffc54ec38ded4882104f47f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53fdd4fffc54ec38ded4882104f47f3">&#9670;&nbsp;</a></span>fill_rnorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::fill_rnorm </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>sd</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>Seed for the rng. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean,sd</td><td>Parameters for the generator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="ad8ed76dc3cbefb7f29b5e231dce4bbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ed76dc3cbefb7f29b5e231dce4bbdb">&#9670;&nbsp;</a></span>fill_runif()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::fill_runif </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>min</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set diagonal entries to 1 and non-diagonal entries to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>Seed for the rng. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min,max</td><td>Parameters for the generator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a718476cde182c47938541abc5970a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718476cde182c47938541abc5970a650">&#9670;&nbsp;</a></span>fill_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::fill_val </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values to input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value to set all data values to.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a9a30aeae3b5f58248adbdd7ff0faf7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a30aeae3b5f58248adbdd7ff0faf7a4">&#9670;&nbsp;</a></span>fill_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::fill_zero</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values to zero. </p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a8cf093ad96ed3b00dc549bdf45e873dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf093ad96ed3b00dc549bdf45e873dd">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified value. </p>
<p>All processes receive the return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the desired value, 0-indexed. The numbering considers the internal storage as a 1-dimensional array.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a83c4b62f9ad2de99929bd75fe040e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c4b62f9ad2de99929bd75fe040e971">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified value. </p>
<p>All processes receive the return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i,j</td><td>The indices of the desired value, 0-indexed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="accc07ece006268f5c81c7d991b3aa0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc07ece006268f5c81c7d991b3aa0b2">&#9670;&nbsp;</a></span>get_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::get_col </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">fml::cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified column. </p>
<p>The return vector of column values is set on all processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The desired column, 0-indexed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The column values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If <code>j</code> is an inappropriate value (i.e. does not refer to a matrix column), then the method will throw a <code>logic_error</code> exception. If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="ad18fdd686b71048cfae11d0ee2a678fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18fdd686b71048cfae11d0ee2a678fb">&#9670;&nbsp;</a></span>get_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfml_1_1cpuvec.html">fml::cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified row. </p>
<p>The return vector of row values is set on all processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The desired row, 0-indexed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The row values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If <code>i</code> is an inappropriate value (i.e. does not refer to a matrix row), then the method will throw a <code>logic_error</code> exception. If a reallocation is triggered and fails, a <code>bad_alloc</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a18538d123de5c26f7278f343459cff84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18538d123de5c26f7278f343459cff84">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print some brief information about the object. </p>
<p>Printing will only be done by rank 0.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="ac5045c7d3304e692ae476ea2189fb6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5045c7d3304e692ae476ea2189fb6e9">&#9670;&nbsp;</a></span>inherit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::inherit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfml_1_1grid.html">fml::grid</a> &amp;&#160;</td>
          <td class="paramname"><em>blacs_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL *&#160;</td>
          <td class="paramname"><em>data_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destruct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal object storage to the specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Value storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns of the matrix. The product of these should be the length of the input <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bf_rows,bf_cols</td><td>Row/column blocking factor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_on_destruct</td><td>Should the object destructor free the internal array <code>data</code>?</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="abf4ab57e8e3ad0b7e8cdf147582c39d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4ab57e8e3ad0b7e8cdf147582c39d0">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the two objects are not the same. Uses same internal logic as the <code>==</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Comparison</td><td>object.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a705bca92369247fce9b62d633a16dfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705bca92369247fce9b62d633a16dfcc">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt; &amp; <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator that sets the LHS to a shallow copy of the input. Desctruction of the LHS object will not result in the internal array storage being freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a65fe8d63ee7e3e82ee9d4b6c182452f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fe8d63ee7e3e82ee9d4b6c182452f3">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfml_1_1mpimat.html">mpimat</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the two objects are the same. </p>
<p>All processes receive the return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Comparison</td><td>object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the dimensions mismatch, then <code>false</code> is necessarily returned. Next, if the grid objects have different ordinal context numbers, then <code>false</code> is returned. Next, if the pointer to the internal storage arrays match, then <code>true</code> is returned. Otherwise the objects are compared value by value.</dd></dl>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a028224f51f9fe269bb63182ad4d69282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028224f51f9fe269bb63182ad4d69282">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::print </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ndigits</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_final_blank</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print all values in the object. </p>
<p>Printing will only be done by rank 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of decimal digits to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_final_blank</td><td>Should a final blank line be printed?</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a7185d9e8efe8cad812e9a7722d654b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7185d9e8efe8cad812e9a7722d654b79">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the internal object storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns needed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 Resizing triggers a re-allocation.</p>
<p><b>Exceptions</b><br  />
 If the reallocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a7c1e030381f04d7ea0f82b8561a894f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1e030381f04d7ea0f82b8561a894f3">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">len_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bf_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the internal object storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows,ncols</td><td>Number rows/columns needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bf_rows,bf_cols</td><td>Row/column blocking factor.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 Resizing triggers a re-allocation.</p>
<p><b>Exceptions</b><br  />
 If the reallocation fails, a <code>bad_alloc</code> exception will be thrown. If the input values are invalid, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a566ee3cc25e640c844e71b8ee2176927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566ee3cc25e640c844e71b8ee2176927">&#9670;&nbsp;</a></span>rev_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::rev_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the columns of the matrix. </p>
<p><b>Communication Details</b><br  />
 The method will communicate with all columns in the BLACS grid. </p>

</div>
</div>
<a id="aa7360c3d86d858bfc50447dd0ea4f171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7360c3d86d858bfc50447dd0ea4f171">&#9670;&nbsp;</a></span>rev_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::rev_rows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the rows of the matrix. </p>
<p><b>Communication Details</b><br  />
 The method will communicate with all rows in the BLACS grid. </p>

</div>
</div>
<a id="ad636a7172741c2ed90471a4f98532742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad636a7172741c2ed90471a4f98532742">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply all values by the input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Scaling value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a098909a214f5cdcc5a71c8268895047c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098909a214f5cdcc5a71c8268895047c">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the storage at the specified index with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i,j</td><td>The indices of the desired value, 0-indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="a4e7c577c61e5ab6907dfb31cf493ddfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7c577c61e5ab6907dfb31cf493ddfe">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the storage at the specified index with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the desired value, 0-indexed. The numbering considers the internal storage as a 1-dimensional array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Setter value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If indices are out of bounds, the method will throw a <code>runtime_error</code> exception.</p>
<p><b>Communication Details</b><br  />
 The method has no communication. </p>

</div>
</div>
<a id="af77fefa817a7d4812c96a9ad680534d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77fefa817a7d4812c96a9ad680534d3">&#9670;&nbsp;</a></span>set_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::set_col </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the specified column. </p>
<p>The return vector of column values is set on all processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The desired column, 0-indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The column values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Memory Allocations</b><br  />
 If the output dimension is inappropriately sized, it will automatically be re-allocated.</p>
<p><b>Exceptions</b><br  />
 If <code>j</code> is an inappropriate value (i.e. does not refer to a matrix column), then the method will throw a <code>logic_error</code> exception. If the vector is inappropriately sized, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<a id="a6e2066c04e3974602ba452b1ae42bf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2066c04e3974602ba452b1ae42bf36">&#9670;&nbsp;</a></span>set_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfml_1_1mpimat.html">fml::mpimat</a>&lt; REAL &gt;::set_row </td>
          <td>(</td>
          <td class="paramtype">const len_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfml_1_1cpuvec.html">cpuvec</a>&lt; REAL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the specified row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The desired row, 0-indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The row values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Exceptions</b><br  />
 If <code>i</code> is an inappropriate value (i.e. does not refer to a matrix row), then the method will throw a <code>logic_error</code> exception. If the vector is inappropriately sized, a <code>runtime_error</code> exception will be thrown.</p>
<p><b>Communication Details</b><br  />
 The method will communicate across all processes in the BLACS grid. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>fml/src/fml/mpi/<a class="el" href="mpimat_8hh_source.html">mpimat.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup___enumerations_html_ggaf4b9b0520217d168c1c074127e37f483a6256d0af0626d3f43493ed101b1e8576"><div class="ttname"><a href="group___enumerations.html#ggaf4b9b0520217d168c1c074127e37f483a6256d0af0626d3f43493ed101b1e8576">fml::PROC_GRID_SQUARE</a></div><div class="ttdeci">@ PROC_GRID_SQUARE</div><div class="ttdef"><b>Definition:</b> grid.hh:44</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefml.html">fml</a></li><li class="navelem"><a class="el" href="classfml_1_1mpimat.html">mpimat</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
